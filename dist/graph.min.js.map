{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6","webpack:/webpack/bootstrap e1864f16bde87f058b9b?d244","webpack:///src/private.es6.js?1619","webpack:///src/graph.es6.js?8eb6"],"names":["webpackUniversalModuleDefinition","root","factory","exports","module","define","amd","this","installedModules","__webpack_require__","moduleId","id","loaded","modules","call","m","c","p","window","__graphjs__private__","_options","Symbol","_vertices","_edges","_reverseEdges","_sources","_sinks","_edgeCount","_extractTwoArgs","_extractThreeArgs","_listeners","_trigger","_verticesFrom","_verticesTo","_edgesFrom","_edgesTo","_verticesWithPathTo","_verticesWithPathFrom","_paths","_expectVertices","_expectVerticesAbsent","_expectEdges","_expectEdgesAbsent","_expectNoConnectedEdges","Object","assign","Graph","_privateEs6Js","Map","Set","parts","Array","_len","_key","arguments","_iterator","iterator","_step","_iteratorNormalCompletion","next","done","part","value","_iterator2","_step2","_iteratorNormalCompletion2","key","_part","isArray","createEdge","addVertex","on","event","handler","has","set","get","add","off","_value","_iterator3","_step3","_iteratorNormalCompletion3","addNewVertex","_Graph$_extractTwoArgs2","vertex","setVertex","_Graph$_extractTwoArgs32","ensureVertex","_Graph$_extractTwoArgs42","hasVertex","_Graph$_extractTwoArgs52","removeExistingVertex","destroyExistingVertex","_iterator4","verticesFrom","_step4","_iteratorNormalCompletion4","to","_step4$value","removeEdge","_iterator5","verticesTo","_step5","_iteratorNormalCompletion5","from","_step5$value","removeVertex","destroyVertex","vertexCount","size","vertexValue","addNewEdge","_Graph$_extractThreeArgs2","edge","createNewEdge","_Graph$_extractThreeArgs32","setEdge","_Graph$_extractThreeArgs42","spanEdge","_Graph$_extractThreeArgs52","hasEdge","addEdge","_Graph$_extractThreeArgs62","ensureEdge","_Graph$_extractThreeArgs72","_Graph$_extractThreeArgs82","removeExistingEdge","_Graph$_extractTwoArgs62","inDegree","outDegree","_Graph$_extractTwoArgs72","edgeCount","_Graph$_extractTwoArgs82","_Graph$_extractTwoArgs92","edgeValue","_Graph$_extractTwoArgs102","undefined","vertices","_iteratorNormalCompletion6","_didIteratorError6","_iteratorError6","_iterator6","_step6","_step6$value","edges","_iteratorNormalCompletion7","_didIteratorError7","_iteratorError7","_iterator7","_step7","_iteratorNormalCompletion8","_didIteratorError8","_iteratorError8","_iterator8","_step8","keys","_iteratorNormalCompletion9","_didIteratorError9","_iteratorError9","_iterator9","_step9","_iteratorNormalCompletion10","_didIteratorError10","_iteratorError10","_iterator10","_step10","edgesFrom","_iteratorNormalCompletion11","_didIteratorError11","_iteratorError11","_iterator11","_step11","edgesTo","_iteratorNormalCompletion12","_didIteratorError12","_iteratorError12","_iterator12","_step12","verticesWithPathFrom","_step13$value","verticesWithPathTo","_step14$value","sources","_iteratorNormalCompletion15","_didIteratorError15","_iteratorError15","_iterator15","_step15","sinks","_iteratorNormalCompletion16","_didIteratorError16","_iteratorError16","_iterator16","_step16","other","_iterator17","_step17","_iteratorNormalCompletion17","_step17$value","_iterator18","_step18","_iteratorNormalCompletion18","_step18$value","_iterator19","_step19","_iteratorNormalCompletion19","_step19$value","_iterator20","_step20","_iteratorNormalCompletion20","_step20$value","clearEdges","_iterator21","_step21","_iteratorNormalCompletion21","_step21$value","clear","_iterator22","_step22","_iteratorNormalCompletion22","_step22$value","equals","eqV","length","x","y","eqE","_iterator23","_step23","_iteratorNormalCompletion23","_step23$value","_iterator24","_step24","_iteratorNormalCompletion24","_step24$value","apply","cycles","pointStack","markedStack","mark","_this","backtrack","_iteratorNormalCompletion25","_didIteratorError25","_iteratorError25","_iterator25","_step25","_step25$value","a","v","out","w","o","u","push","_arr$_i","found","pop","map","regeneratorRuntime","cycle","result","hasCycle","paths","_Graph$_extractTwoArgs112","stack","pathsFromPrefix","current","_step26$value","indexOf","path","hasPath","degree","mergeIn","mV","v1","v2","mE","_iterator27","_step27","_iteratorNormalCompletion27","_step27$value","_iterator28","_step28","_iteratorNormalCompletion28","_step28$value","clone","trV","trE","transitiveReduction","_iterator29","_step29","_iteratorNormalCompletion29","_step29$value","_iterator30","_step30","_iteratorNormalCompletion30","_step30$value","_iterator31","_step31","_iteratorNormalCompletion31","z","_step31$value","contractPaths","isNexus","_ref","nexuses","concat","_toConsumableArray","filter","_ref2","_ref22","val","_this2","_ref3","_ref32","unhandledVertices","_ref4","_ref42","checkForBlCycle","_iterator32","_step32","_iteratorNormalCompletion32","_step32$value","_iterator33","_step33","_iteratorNormalCompletion33","_step33$value","_iterator34","_iteratorNormalCompletion34","_step34","startingKey","values","BranchlessCycleError","contractionsToAdd","startPath","start","backwards","fromTo","strt","nxt","verticesNext","verticesToRemove","edgesToRemove","constructor","_ref5","_iterator35","_step35","_iteratorNormalCompletion35","_iterator36","_step36","_iteratorNormalCompletion36","_iterator37","_step37","_iteratorNormalCompletion37","first","_iterator39","_step39","_iteratorNormalCompletion39","_step39$value","_iterator40","_step40","_iteratorNormalCompletion40","_step40$value","_iterator38","_step38","_iteratorNormalCompletion38","_step38$value","toVal","_iterator41","_step41","_iteratorNormalCompletion41","_step41$value","rememberedPath","_len2","_key2","missingVertices","k","_this3","_bind","VertexNotExistsError","_len3","_key3","presentVertices","_this4","VertexExistsError","_len4","_key4","absentEdges","_this5","EdgeNotExistsError","_len5","_key5","presentEdges","_this6","EdgeExistsError","_iterator42","_step42","_iteratorNormalCompletion42","_step42$value","_iterator43","_step43","_iteratorNormalCompletion43","_step43$value","HasConnectedEdgesError","b","_ref6","_ref7","plugin","name","method","context","_ref8","prototype","_defineProperty","args","_len6","_key6","obj","_context","_iterator44","_step44","_iteratorNormalCompletion44","_name","_Error","_get","getPrototypeOf","_len7","_key7","message","_ref9","_ref92","join","Error","_Error2","_len8","_key8","_Error3","_len9","_key9","_ref10","_ref102","_Error4","_len10","_key10","_ref11","_ref112","_Graph$EdgeExistsError","_len11","_key11","_ref12","_ref122","CycleError","_Error5","_Graph$CycleError"],"mappings":"CAAA,QAAAA,GAAAC,EAAAC,GACA,SAAAC,WAAA,gBAAAC,UAAA,SACAA,OAAAD,QAAAD,QACA,UAAAG,UAAA,YAAAA,OAAAC,IACAD,UAAAH,OACA,UAAAC,WAAA,SACAA,QAAA,SAAAD,QAEAD,GAAA,SAAAC,MACCK,KAAA,WACD,mBCTA,GAAAC,KAGA,SAAAC,GAAAC,GAGA,GAAAF,EAAAE,GACA,MAAAF,GAAAE,GAAAP,OAGA,IAAAC,GAAAI,EAAAE,IACAP,WACAQ,GAAAD,EACAE,OAAA,MAIAC,GAAAH,GAAAI,KAAAV,EAAAD,QAAAC,EAAAA,EAAAD,QAAAM,EAGAL,GAAAQ,OAAA,IAGA,OAAAR,GAAAD,QAKAM,EAAAM,EAAAF,CAGAJ,GAAAO,EAAAR,CAGAC,GAAAQ,EAAA,EAGA,OAAAR,GAAA,wHClCAS,QAAOC,qBAAuBD,OAAOC,wBAE9B,IAAMC,GAA0BF,OAAOC,qBAAqBC,UAA2BC,OAAO,uBAC9F,IAAMC,GAA0BJ,OAAOC,qBAAqBG,WAA2BD,OAAO,yBAC9F,IAAME,GAA0BL,OAAOC,qBAAqBI,QAA2BF,OAAO,mBAC9F,IAAMG,GAA0BN,OAAOC,qBAAqBK,eAA2BH,OAAO,kCAC9F,IAAMI,GAA0BP,OAAOC,qBAAqBM,UAA2BJ,OAAO,uBAC9F,IAAMK,GAA0BR,OAAOC,qBAAqBO,QAA2BL,OAAO,mBAC9F,IAAMM,GAA0BT,OAAOC,qBAAqBQ,YAA2BN,OAAO,4BAC9F,IAAMO,GAA0BV,OAAOC,qBAAqBS,iBAA2BP,OAAO,2DAC9F,IAAMQ,GAA0BX,OAAOC,qBAAqBU,mBAA2BR,OAAO,kFAC9F,IAAMS,GAA0BZ,OAAOC,qBAAqBW,YAA2BT,OAAO,2BAC9F,IAAMU,GAA0Bb,OAAOC,qBAAqBY,UAA2BV,OAAO,uBAC9F,IAAMW,GAA0Bd,OAAOC,qBAAqBa,eAA2BX,OAAO,kCAC9F,IAAMY,GAA0Bf,OAAOC,qBAAqBc,aAA2BZ,OAAO,8BAC9F,IAAMa,GAA0BhB,OAAOC,qBAAqBe,YAA2Bb,OAAO,4BAC9F,IAAMc,GAA0BjB,OAAOC,qBAAqBgB,UAA2Bd,OAAO,wBAC9F,IAAMe,GAA0BlB,OAAOC,qBAAqBiB,qBAA2Bf,OAAO,gDAC9F,IAAMgB,GAA0BnB,OAAOC,qBAAqBkB,uBAA2BhB,OAAO,oDAC9F,IAAMiB,GAA0BpB,OAAOC,qBAAqBmB,QAA2BjB,OAAO,mBAC9F,IAAMkB,GAA0BrB,OAAOC,qBAAqBoB,iBAA2BlB,OAAO,sCAC9F,IAAMmB,GAA0BtB,OAAOC,qBAAqBqB,uBAA2BnB,OAAO,iDAC9F,IAAMoB,GAA0BvB,OAAOC,qBAAqBsB,cAA2BpB,OAAO,+BAC9F,IAAMqB,GAA0BxB,OAAOC,qBAAqBuB,oBAA2BrB,OAAO,4CAC9F,IAAMsB,GAA0BzB,OAAOC,qBAAqBwB,yBAA2BtB,OAAO,wDAErGuB,QAAOC,OAAO3B,OAAOC,sBACpBC,SAAAA,EACAE,UAAAA,EACAC,OAAAA,EACAC,cAAAA,EACAC,SAAAA,EACAC,OAAAA,EACAC,WAAAA,EACAC,gBAAAA,EACAC,kBAAAA,EACAC,WAAAA,EACAC,SAAAA,EACAC,cAAAA,EACAC,YAAAA,EACAC,WAAAA,EACAC,SAAAA,EACAC,oBAAAA,EACAC,sBAAAA,EACAC,OAAAA,EACAC,gBAAAA,EACAC,sBAAAA,EACAC,aAAAA,EACAC,mBAAAA,EACAC,wBAAAA,s4DC9CM,OAsCcG,GAAK,WAEd,QAFSA,YAAAA,EAInBvC,MAAIwC,EAAAzB,WAAkB,GAAI0B,IAC1BzC,MAAIwC,EAAAxB,QAAkB,GAAIyB,IAG1BzC,MAAIwC,EAAAvB,eAAkB,GAAIwB,IAC1BzC,MAAIwC,EAAAtB,UAAkB,GAAIwB,IAC1B1C,MAAIwC,EAAArB,QAAkB,GAAIuB,IAC1B1C,MAAIwC,EAAApB,YAAkB,CAGtBpB,MAAIwC,EAAAjB,YAAe,GAAIkB,IAGvBzC,MAAIwC,EAAA3B,+EAfU8B,EAAKC,MAAAC,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAA,CAALH,EAAKG,GAAAC,UAAAD,OAgBnB,IAAA,GAAAE,GAAiBL,EAAK7B,OAAAmC,YAAAC,IAAAC,GAAAD,EAAAF,EAAAI,QAAAC,MAAAF,EAAA,KAAE,IAAfG,GAAIJ,EAAAK,KACZ,MAAMD,YAAgBV,SAAUU,YAAgBjB,QAAQ,CACvDA,OAAOC,OAAOtC,KAAIwC,EAAA3B,UAAYyC,2IAKhC,IAAA,GAAAE,GAAiBb,EAAK7B,OAAAmC,YAAAQ,IAAAC,GAAAD,EAAAD,EAAAJ,QAAAC,MAAAK,EAAA,KAAE,IAAfJ,GAAIG,EAAAF,KACZ,IAAID,YAAgBV,OAAO,SACPU,EAAI,MAAlBK,GAAGC,EAAA,MAAEL,GAAKK,EAAA,EACf,IAAIhB,MAAMiB,QAAQF,GAAM,CACvB3D,KAAK8D,WAAWH,EAAKJ,OACf,CACNvD,KAAK+D,UAAUJ,EAAKJ,oGA/BJhB,mBA6FlB,QAAAyB,GAACC,EAAOC,GACT,IAAKlE,KAAIwC,EAAAjB,YAAa4C,IAAIF,GAAQ,CACjCjE,KAAIwC,EAAAjB,YAAa6C,IAAIH,EAAO,GAAIvB,MAEjC1C,KAAIwC,EAAAjB,YAAa8C,IAAIJ,GAAOK,IAAIJ,sBAQ9B,QAAAK,GAACN,EAAOC,GACV,GAAIlE,KAAIwC,EAAAjB,YAAa4C,IAAIF,GAAQ,CAChCjE,KAAIwC,EAAAjB,YAAa8C,IAAIJ,GAAM,UAAQC,4BAI3B,QAAAX,GAACU,EAAOO,8CACjB,IAAA,GAAAC,IAAoBzE,KAAIwC,EAAAjB,YAAa8C,IAAIJ,QAAYnD,OAAAmC,YAAAyB,IAAAC,GAAAD,EAAAD,EAAArB,QAAAC,MAAAsB,EAAA,KAAE,IAA9CT,GAAOQ,EAAAnB,KACfW,GAAQM,4HA0EE,QAAAI,GAACjB,EAAKJ,SACFhB,EAAKC,EAAAnB,iBAAkBsC,EAAKJ,eAA1CI,GAAGkB,EAAA,EAAEtB,GAAKsB,EAAA,EACX7E,MAAIwC,EAAAP,uBAAwB0B,EAC5B3D,MAAIwC,EAAAzB,WAAYqD,IAAIT,EAAKJ,EACzBvD,MAAIwC,EAAAxB,QAASoD,IAAIT,EAAK,GAAIlB,KAC1BzC,MAAIwC,EAAAvB,eAAgBmD,IAAIT,EAAK,GAAIjB,KACjC1C,MAAIwC,EAAAtB,UAAWoD,IAAIX,EACnB3D,MAAIwC,EAAArB,QAASmD,IAAIX,EACjB3D,MAAIwC,EAAAhB,UAAW,eAAmBxB,KAAK8E,OAAOnB,GAC9C3D,MAAIwC,EAAAhB,UAAW,kBAAmBxB,KAAK8E,OAAOnB,6BAStC,QAAAoB,GAACpB,EAAKJ,SACChB,EAAKC,EAAAnB,iBAAkBsC,EAAKJ,eAA1CI,GAAGqB,EAAA,EAAEzB,GAAKyB,EAAA,EACXhF,MAAIwC,EAAAR,iBAAkB2B,EACtB3D,MAAIwC,EAAAzB,WAAYqD,IAAIT,EAAKJ,EACzBvD,MAAIwC,EAAAhB,UAAW,kBAAmBxB,KAAK8E,OAAOnB,gCASnC,QAAAsB,GAACtB,EAAKJ,SACFhB,EAAKC,EAAAnB,iBAAkBsC,EAAKJ,eAA1CI,GAAGuB,EAAA,EAAE3B,GAAK2B,EAAA,EACX,KAAKlF,KAAKmF,UAAUxB,GAAM,CACzB3D,KAAK4E,aAAajB,EAAKJ,6BAUhB,QAAAQ,GAACJ,EAAKJ,SACChB,EAAKC,EAAAnB,iBAAkBsC,EAAKJ,eAA1CI,GAAGyB,EAAA,EAAE7B,GAAK6B,EAAA,EACX,IAAIpF,KAAKmF,UAAUxB,GAAM,CACxB3D,KAAK+E,UAAUpB,EAAKJ,OACd,CACNvD,KAAK4E,aAAajB,EAAKJ,wCAaL,QAAA8B,GAAC1B,GACpB3D,KAAIwC,EAAAR,iBAAkB2B,EACtB3D,MAAIwC,EAAAJ,yBAA0BuB,EAC9B3D,MAAIwC,EAAAzB,WAAW,UAAQ4C,EACvB3D,MAAIwC,EAAAtB,UAAU,UAAQyC,EACtB3D,MAAIwC,EAAArB,QAAQ,UAAQwC,EACpB3D,MAAIwC,EAAAhB,UAAW,iBAAkBmC,wCAQb,QAAA2B,GAAC3B,GACrB3D,KAAIwC,EAAAR,iBAAkB2B,8CACtB,IAAA,GAAA4B,GAAiBvF,KAAKwF,aAAa7B,GAAI7C,OAAAmC,YAAAwC,IAAAC,GAAAD,EAAAF,EAAAnC,QAAAC,MAAAqC,EAAA,KAAE,uBAA/BC,GAAEC,EAAA,EAA+B5F,MAAK6F,WAAWlC,EAAMgC,0IACjE,IAAA,GAAAG,GAAmB9F,KAAK+F,WAAWpC,GAAI7C,OAAAmC,YAAA+C,IAAAC,GAAAD,EAAAF,EAAA1C,QAAAC,MAAA4C,EAAA,KAAE,uBAA/BC,GAAIC,EAAA,EAA6BnG,MAAK6F,WAAWK,EAAMvC,+FACjE3D,KAAKqF,qBAAqB1B,+BASf,QAAAyC,GAACzC,GACZ,GAAI3D,KAAKmF,UAAUxB,GAAM,CACxB3D,KAAKqF,qBAAqB1B,iCASf,QAAA0C,GAAC1C,GACb,GAAI3D,KAAKmF,UAAUxB,GAAM,CACxB3D,KAAKsF,sBAAsB3B,+BAUlB,QAAA2C,KAAK,MAAOtG,MAAIwC,EAAAzB,WAAYwF,8BAO9B,QAAApB,GAACxB,GAAO,MAAO3D,MAAIwC,EAAAzB,WAAYoD,IAAIR,yBAQtC,QAAAmB,GAACnB,GACN3D,KAAIwC,EAAAR,iBAAkB2B,EACtB,QAAQA,EAAK3D,KAAKwG,YAAY7C,+BAcpB,QAAA6C,GAAC7C,GAAO,MAAO3D,MAAIwC,EAAAzB,WAAYsD,IAAIV,6BAiBpC,QAAA8C,GAACP,EAAMP,EAAIpC,SACAhB,EAAKC,EAAAlB,mBAAoB4E,EAAMP,EAAIpC,eAAtD2C,GAAIQ,EAAA,EAAEf,GAAEe,EAAA,EAAEnD,GAAKmD,EAAA,EAChB1G,MAAIwC,EAAAL,qBAAsB+D,EAAMP,GAChC3F,MAAIwC,EAAAR,iBAAkBkE,EAAMP,EAC5B3F,MAAIwC,EAAAxB,QAASqD,IAAI6B,GAAM9B,IAAIuB,EAAIpC,EAC/BvD,MAAIwC,EAAAvB,eAAgBoD,IAAIsB,GAAIrB,IAAI4B,EAChClG,MAAIwC,EAAApB,aAAgB,CACpBpB,MAAIwC,EAAAtB,UAAU,UAAQyE,EACtB3F,MAAIwC,EAAArB,QAAQ,UAAQ+E,EACpBlG,MAAIwC,EAAAhB,UAAW,aAAiBxB,KAAK2G,KAAKT,EAAMP,GAChD3F,MAAIwC,EAAAhB,UAAW,gBAAiBxB,KAAK2G,KAAKT,EAAMP,iCAWpC,QAAAiB,GAACV,EAAMP,EAAIpC,SACHhB,EAAKC,EAAAlB,mBAAoB4E,EAAMP,EAAIpC,eAAtD2C,GAAIW,EAAA,EAAElB,GAAEkB,EAAA,EAAEtD,GAAKsD,EAAA,EAChB7G,MAAIwC,EAAAL,qBAAsB+D,EAAMP,GAChC3F,MAAKiF,aAAaiB,EAClBlG,MAAKiF,aAAaU,EAClB3F,MAAKyG,WAAWP,EAAMP,EAAIpC,0BAUpB,QAAAuD,GAACZ,EAAMP,EAAIpC,SACGhB,EAAKC,EAAAlB,mBAAoB4E,EAAMP,EAAIpC,eAAtD2C,GAAIa,EAAA,EAAEpB,GAAEoB,EAAA,EAAExD,GAAKwD,EAAA,EAChB/G,MAAIwC,EAAAN,eAAgBgE,EAAMP,GAC1B3F,MAAIwC,EAAAxB,QAASqD,IAAI6B,GAAM9B,IAAIuB,EAAIpC,EAC/BvD,MAAIwC,EAAAhB,UAAW,gBAAiBxB,KAAK2G,KAAKT,EAAMP,4BAYzC,QAAAqB,GAACd,EAAMP,EAAIpC,SACEhB,EAAKC,EAAAlB,mBAAoB4E,EAAMP,EAAIpC,eAAtD2C,GAAIe,EAAA,EAAEtB,GAAEsB,EAAA,EAAE1D,GAAK0D,EAAA,EAChBjH,MAAIwC,EAAAR,iBAAkBkE,EAAMP,EAC5B,KAAK3F,KAAKkH,QAAQhB,EAAMP,GAAK,CAC5B3F,KAAKyG,WAAWP,EAAMP,EAAIpC,2BAYrB,QAAA4D,GAACjB,EAAMP,EAAIpC,SACGhB,EAAKC,EAAAlB,mBAAoB4E,EAAMP,EAAIpC,eAAtD2C,GAAIkB,EAAA,EAAEzB,GAAEyB,EAAA,EAAE7D,GAAK6D,EAAA,EAChB,IAAIpH,KAAKkH,QAAQhB,EAAMP,GAAK,CAC3B3F,KAAK8G,QAAQZ,EAAMP,EAAIpC,OACjB,CACNvD,KAAKyG,WAAWP,EAAMP,EAAIpC,8BAclB,QAAA8D,GAACnB,EAAMP,EAAIpC,SACAhB,EAAKC,EAAAlB,mBAAoB4E,EAAMP,EAAIpC,eAAtD2C,GAAIoB,EAAA,EAAE3B,GAAE2B,EAAA,EAAE/D,GAAK+D,EAAA,EAChB,KAAKtH,KAAKkH,QAAQhB,EAAMP,GAAK,CAC5B3F,KAAK4G,cAAcV,EAAMP,EAAIpC,8BAarB,QAAAO,GAACoC,EAAMP,EAAIpC,SACAhB,EAAKC,EAAAlB,mBAAoB4E,EAAMP,EAAIpC,eAAtD2C,GAAIqB,EAAA,EAAE5B,GAAE4B,EAAA,EAAEhE,GAAKgE,EAAA,EAChB,IAAIvH,KAAKkH,QAAQhB,EAAMP,GAAK,CAC3B3F,KAAK8G,QAAQZ,EAAMP,EAAIpC,OACjB,CACNvD,KAAK4G,cAAcV,EAAMP,EAAIpC,sCAab,QAAAiE,GAACtB,EAAMP,SACXpD,EAAKC,EAAAnB,iBAAkB6E,EAAMP,eAAzCO,GAAIuB,EAAA,EAAE9B,GAAE8B,EAAA,EACTzH,MAAIwC,EAAAN,eAAgBgE,EAAMP,GAC1B3F,MAAIwC,EAAAxB,QAASqD,IAAI6B,GAAK,UAAQP,EAC9B3F,MAAIwC,EAAAvB,eAAgBoD,IAAIsB,GAAG,UAAQO,EACnClG,MAAIwC,EAAApB,aAAgB,CACpB,IAAIpB,KAAM0H,SAAS/B,KAAU,EAAG,CAAE3F,KAAIwC,EAAAtB,UAAWoD,IAAIqB,GACrD,GAAI3F,KAAK2H,UAAUzB,KAAU,EAAG,CAAElG,KAAIwC,EAAArB,QAASmD,IAAI4B,GACnDlG,KAAIwC,EAAAhB,UAAW,gBAAiB0E,EAAMP,8BAS7B,QAAAE,GAACK,EAAMP,SACHpD,EAAKC,EAAAnB,iBAAkB6E,EAAMP,eAAzCO,GAAI0B,EAAA,EAAEjC,GAAEiC,EAAA,EACT,IAAI5H,KAAKkH,QAAQhB,EAAMP,GAAK,CAC3B3F,KAAKwH,mBAAmBtB,EAAMP,6BAUvB,QAAAkC,KAAK,MAAO7H,MAAIwC,EAAApB,mCAQlB,QAAA8F,GAAChB,EAAMP,SACApD,EAAKC,EAAAnB,iBAAkB6E,EAAMP,eAAzCO,GAAI4B,EAAA,EAAEnC,GAAEmC,EAAA,EACT,OAAO9H,MAAKmF,UAAUe,IACrBlG,KAAKmF,UAAUQ,IACf3F,KAAIwC,EAAAxB,QAASmD,IAAI+B,IACjBlG,KAAIwC,EAAAxB,QAASqD,IAAI6B,GAAM/B,IAAIwB,uBASzB,QAAAgB,GAACT,EAAMP,SACGpD,EAAKC,EAAAnB,iBAAkB6E,EAAMP,eAAzCO,GAAI6B,EAAA,EAAEpC,GAAEoC,EAAA,EACT/H,MAAIwC,EAAAN,eAAgBgE,EAAMP,GAC1B,SAASO,EAAMP,GAAK3F,KAAKgI,UAAU9B,EAAMP,6BAejC,QAAAqC,GAAC9B,EAAMP,SACFpD,EAAKC,EAAAnB,iBAAkB6E,EAAMP,eAAzCO,GAAI+B,EAAA,EAAEtC,GAAEsC,EAAA,EACT,OAAOjI,MAAKkH,QAAQhB,EAAMP,GAAM3F,KAAIwC,EAAAxB,QAASqD,IAAI6B,GAAM7B,IAAIsB,GAAMuC,0DAwBzD,QAAAC,QACJ9E,GAAI+E,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EACE9E,oFADNN,EAAO,GAAIX,2CACG1C,KAAIwC,EAAAzB,WAAWD,OAAAmC,yEAAvBU,GAAG8E,EAAA,QACRzI,KAAKmF,UAAUxB,KAASN,EAAKc,IAAIR,IAAI,iBACxCN,EAAKiB,IAAIX,mBACH3D,MAAK8E,OAAOnB,kWAgBpB7C,OAAOmC,eAAS,QAAAM,KAAK,MAAOvD,MAAKmI,wDAkB5B,QAAAO,QACDrF,GAAIsF,EAAAC,EAAAC,EAAAC,EAAAC,EACC7C,EAAI8C,EAAAC,EAAAC,EAAAC,EAAAC,EAEHzD,oFAHNtC,EAAO,GAAIZ,2CACEzC,KAAIwC,EAAAxB,QAASqI,OAAMvI,OAAAmC,2DAA3BiD,EAAI6C,EAAAxF,KACZF,GAAKe,IAAI8B,EAAM,GAAIxD,6CACJ1C,KAAIwC,EAAAxB,QAASqD,IAAI6B,GAAMmD,OAAMvI,OAAAmC,4DAAnC0C,EAAEyD,EAAA7F,YACLF,EAAKgB,IAAI6B,GAAM/B,IAAIwB,IAAO3F,KAAKkH,QAAQhB,EAAMP,IAAG,iBACpDtC,EAAKgB,IAAI6B,GAAM5B,IAAIqB,mBACb3F,MAAK2G,KAAKT,EAAMP,mqBAuBd,QAAAH,GAAC7B,GACZ3D,KAAIwC,EAAAR,iBAAkB2B,EACtB,OAAO3D,MAAIwC,EAAAf,eAAgBkC,wDAEZ,QAAAJ,GAAC2C,MACZ7C,GAAIiG,EAAAC,EAAAC,EAAAC,EAAAC,EACC/D,oFADLtC,EAAO,GAAIX,2CACA1C,KAAIwC,EAAAxB,QAASqD,IAAI6B,GAAMmD,OAAMvI,OAAAmC,2DAAnC0C,EAAE+D,EAAAnG,YACLF,EAAKc,IAAIwB,IAAO3F,KAAKkH,QAAQhB,EAAMP,IAAG,iBAC1CtC,EAAKiB,IAAIqB,mBACH3F,MAAK8E,OAAOa,qXAsBX,QAAAI,GAACpC,GACV3D,KAAIwC,EAAAR,iBAAkB2B,EACtB,OAAO3D,MAAIwC,EAAAd,aAAciC,sDAEZ,QAAAJ,GAACoC,MACVtC,GAAIsG,EAAAC,EAAAC,EAAAC,EAAAC,EACC7D,oFADL7C,EAAO,GAAIX,2CACE1C,KAAIwC,EAAAvB,eAAgBoD,IAAIsB,GAAG7E,OAAAmC,2DAAnCiD,EAAI6D,EAAAxG,YACPF,EAAKc,IAAI+B,IAASlG,KAAKkH,QAAQhB,EAAMP,IAAG,iBAC5CtC,EAAKiB,IAAI4B,mBACHlG,MAAK8E,OAAOoB,oXAuBZ,QAAA8D,GAACrG,GACT3D,KAAIwC,EAAAR,iBAAkB2B,EACtB,OAAO3D,MAAIwC,EAAAb,YAAagC,qDAEZ,QAAAJ,GAAC2C,MACT7C,GAAI4G,EAAAC,EAAAC,EAAAC,EAAAC,EACC1E,oFADLtC,EAAO,GAAIX,2CACA1C,KAAIwC,EAAAxB,QAASqD,IAAI6B,GAAMmD,OAAMvI,OAAAmC,2DAAnC0C,EAAE0E,EAAA9G,YACLF,EAAKc,IAAIwB,IAAO3F,KAAKkH,QAAQhB,EAAMP,IAAG,iBAC1CtC,EAAKiB,IAAIqB,mBACH3F,MAAK2G,KAAKT,EAAMP,kXAuBlB,QAAA2E,GAAC3G,GACP3D,KAAIwC,EAAAR,iBAAkB2B,EACtB,OAAO3D,MAAIwC,EAAAZ,UAAW+B,mDAEZ,QAAAJ,GAACoC,MACPtC,GAAIkH,EAAAC,EAAAC,EAAAC,EAAAC,EACCzE,oFADL7C,EAAO,GAAIX,2CACE1C,KAAIwC,EAAAvB,eAAgBoD,IAAIsB,GAAG7E,OAAAmC,2DAAnCiD,EAAIyE,EAAApH,YACPF,EAAKc,IAAI+B,IAASlG,KAAKkH,QAAQhB,EAAMP,IAAG,iBAC5CtC,EAAKiB,IAAI4B,mBACHlG,MAAK2G,KAAKT,EAAMP,+XAsBL,QAAAiF,GAAC1E,GACpBlG,KAAIwC,EAAAR,iBAAkBkE,EACtB,OAAOlG,MAAIwC,EAAAV,uBAAwBoE,EAAM,GAAIxD,mEAEtB,QAAAa,GAAC2C,EAAM7C,mBACpBsC,0HAAO3F,KAAKwF,aAAaU,GAAKpF,OAAAmC,yEAA9B0C,GAAEkF,EAAA,SACNxH,EAAKc,IAAIwB,IAAO3F,KAAKkH,QAAQhB,EAAMP,IAAG,iBAC1CtC,EAAKiB,IAAIqB,mBACH3F,MAAK8E,OAAOa,kCACX3F,KAAIwC,EAAAV,uBAAwB6D,EAAItC,GAAK,KAAA,8XAsB7B,QAAAyH,GAACnF,GAClB3F,KAAIwC,EAAAR,iBAAkB2D,EACtB,OAAO3F,MAAIwC,EAAAX,qBAAsB8D,EAAI,GAAIjD,iEAEpB,QAAAa,GAACoC,EAAItC,mBAChB6C,0HAASlG,KAAK+F,WAAWJ,GAAG7E,OAAAmC,yEAA5BiD,GAAI6E,EAAA,SACR1H,EAAKc,IAAI+B,IAASlG,KAAKkH,QAAQhB,EAAMP,IAAG,iBAC5CtC,EAAKiB,IAAI4B,mBACHlG,MAAK8E,OAAOoB,kCACXlG,KAAIwC,EAAAX,qBAAsBqE,EAAM7C,GAAK,KAAA,2YAqBvC,QAAA2H,QACH3H,GAAI4H,EAAAC,EAAAC,EAAAC,EAAAC,EACC1H,oFADLN,EAAO,GAAIX,2CACC1C,KAAIwC,EAAAtB,UAAUJ,OAAAmC,2DAArBU,EAAG0H,EAAA9H,WACPvD,KAAKmF,UAAUxB,KAASN,EAAKc,IAAIR,IAAI,iBACxCN,EAAKiB,IAAIX,mBACH3D,MAAK8E,OAAOnB,wYAqBf,QAAA2H,QACDjI,GAAIkI,EAAAC,EAAAC,EAAAC,EAAAC,EACChI,oFADLN,EAAO,GAAIX,2CACC1C,KAAIwC,EAAArB,QAAQL,OAAAmC,2DAAnBU,EAAGgI,EAAApI,WACPvD,KAAKmF,UAAUxB,KAASN,EAAKc,IAAIR,IAAI,iBACxCN,EAAKiB,IAAIX,mBACH3D,MAAK8E,OAAOnB,8WAiBlB,QAAAS,GAACwH,8CACH,IAAA,GAAAC,GAAyB7L,KAAK0I,QAAO5H,OAAAmC,YAAA6I,IAAAC,GAAAD,EAAAD,EAAAzI,QAAAC,MAAA0I,EAAA,KAAE,uBAA7BpI,GAAGqI,EAAA,MAAEzI,GAAKyI,EAAA,EACnB,KAAKJ,EAAM1E,QAAQvD,GAAM,CACxB3D,KAAKwH,mBAAmB7D,OAClB,IAAIJ,IAAUqI,EAAM5D,UAAUrE,GAAM,CAC1C3D,KAAK8G,QAAQnD,EAAKiI,EAAM5D,UAAUrE,4IAGpC,IAAA,GAAAsI,GAAyBjM,KAAKmI,WAAUrH,OAAAmC,YAAAiJ,IAAAC,GAAAD,EAAAD,EAAA7I,QAAAC,MAAA8I,EAAA,KAAE,uBAAhCxI,GAAGyI,EAAA,MAAE7I,GAAK6I,EAAA,EACnB,KAAKR,EAAMzG,UAAUxB,GAAM,CAC1B3D,KAAKqF,qBAAqB1B,OACpB,IAAIJ,IAAUqI,EAAMpF,YAAY7C,GAAM,CAC5C3D,KAAK+E,UAAUpB,EAAKiI,EAAMpF,YAAY7C,4IAGxC,IAAA,GAAA0I,GAAyBT,EAAMzD,WAAUrH,OAAAmC,YAAAqJ,IAAAC,GAAAD,EAAAD,EAAAjJ,QAAAC,MAAAkJ,EAAA,KAAE,uBAAjC5I,GAAG6I,EAAA,MAAEjJ,GAAKiJ,EAAA,EACnB,KAAKxM,KAAKmF,UAAUxB,GAAM,CACzB3D,KAAK4E,aAAajB,EAAKJ,2IAGzB,IAAA,GAAAkJ,GAAyBb,EAAMlD,QAAO5H,OAAAmC,YAAAyJ,IAAAC,GAAAD,EAAAD,EAAArJ,QAAAC,MAAAsJ,EAAA,KAAE,uBAA9BhJ,GAAGiJ,EAAA,MAAErJ,GAAKqJ,EAAA,EACnB,KAAK5M,KAAKkH,QAAQvD,GAAM,CACvB3D,KAAKyG,WAAW9C,EAAKJ,2HASd,QAAAsJ,gDACT,IAAA,GAAAC,GAAkB9M,KAAK0I,QAAO5H,OAAAmC,YAAA8J,IAAAC,GAAAD,EAAAD,EAAA1J,QAAAC,MAAA2J,EAAA,KAAE,uBAAtBrJ,GAAGsJ,EAAA,EAAqBjN,MAAK6F,WAAWlC,qHAM9C,QAAAuJ,gDACJ,IAAA,GAAAC,GAAkBnN,KAAKmI,WAAUrH,OAAAmC,YAAAmK,IAAAC,GAAAD,EAAAD,EAAA/J,QAAAC,MAAAgK,EAAA,KAAE,uBAAzB1J,GAAG2J,EAAA,EAAwBtN,MAAKqG,cAAc1C,sHAwBnD,QAAA4J,GAAC3B,MAAO4B,GAAGzK,UAAA0K,QAAA,GAAA1K,UAAA,KAAAmF,UAAC,SAACwF,EAAEC,SAAKD,KAAIC,GAAE5K,UAAA,MAAE6K,GAAG7K,UAAA0K,QAAA,GAAA1K,UAAA,KAAAmF,UAACsF,EAAGzK,UAAA,qBACxC,KAAM6I,YAAiBrJ,IAAyB,CAAE,MAAO,OACzD,GAAIvC,KAAKsG,gBAAkBsF,EAAMtF,cAAe,CAAE,MAAO,OACzD,GAAItG,KAAK6H,cAAkB+D,EAAM/D,YAAe,CAAE,MAAO,kDACzD,IAAA,GAAAgG,GAAyB7N,KAAKmI,WAAUrH,OAAAmC,YAAA6K,IAAAC,GAAAD,EAAAD,EAAAzK,QAAAC,MAAA0K,EAAA,KAAE,uBAAhCpK,GAAGqK,EAAA,MAAEzK,GAAKyK,EAAA,EACnB,KAAKpC,EAAMzG,UAAUxB,GAAyB,CAAE,MAAO,OACvD,IAAK6J,EAAIjK,EAAOqI,EAAMpF,YAAY7C,GAAMA,GAAM,CAAE,MAAO,+IAExD,IAAA,GAAAsK,GAAyBjO,KAAK0I,QAAO5H,OAAAmC,YAAAiL,IAAAC,GAAAD,EAAAD,EAAA7K,QAAAC,MAAA8K,EAAA,KAAE,uBAA7BxK,GAAGyK,EAAA,MAAE7K,GAAK6K,EAAA,EACnB,KAAKxC,EAAM1E,QAAQvD,GAA2B,CAAE,MAAO,OACvD,IAAKiK,EAAIrK,EAAOqI,EAAM5D,UAAUrE,GAAMA,GAAQ,CAAE,MAAO,oGAExD,MAAO,OACP0K,MAAArO,KAAA+C,yDAoBM,QAAAuL,WAYFC,EACAC,EAAaC,EAGbC,EACMC,EAASC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EA0BTC,oFA1BAP,EAAS,QAATA,GAAUQ,MAAGC,GAAGrM,UAAA0K,QAAA,GAAA1K,UAAA,KAAAmF,aAAKnF,UAAA,aAIpBsM,EAMJC,EAMDC,oFAfLhB,EAAWiB,KAAKL,EAChBV,GAAKnK,IAAI6K,EACTX,GAAYgB,KAAKL,iBACGT,EAAMlJ,aAAa2J,6DAA7BE,GAACI,EAAA,QACNJ,EAAId,EAAW,IAAE,6DACjBc,IAAMd,EAAW,IAAE,2CACZA,WACVa,EAAIM,MAAQ,gCACDjB,EAAKtK,IAAIkL,GAAE,iBAClBC,4BACGX,EAAUU,EAAGC,GAAE,KAAA,YACtBF,EAAIM,MAAQN,EAAIM,OAASJ,EAAEI,yCAG7B,GAAIN,EAAIM,MAAO,CACVH,EAACrH,SACL,GAAG,CACFqH,EAAIf,EAAYmB,KAChBlB,GAAI,UAAQc,SACJA,IAAMJ,GAEhBZ,EAAWoB,yDAtBFhB,GAASiB,IAAAC,mBAAApB,KALfF,KACAC,GAAWtG,UAAEuG,EAAIvG,SAGjBwG,GAAQ1O,2CA2BIA,KAAKmI,WAAUrH,OAAAmC,0EAArBiM,GAACD,EAAA,EACVT,KACAC,GAAO,GAAI/L,4BACJiM,EAAUO,GAAE,KAAA,kXAUhB,QAAAY,KACJ,GAAIC,GAAS/P,KAAKsO,SAASlL,MAC3B,OAAO2M,GAAO1M,KAAO,KAAO0M,EAAOxM,8BAQ5B,QAAAyM,KAAK,OAAQhQ,KAAKsO,SAASlL,OAAOC,0BAsBrC,QAAA4M,GAAC/J,EAAMP,SACEpD,EAAKC,EAAAnB,iBAAkB6E,EAAMP,eAAzCO,GAAIgK,EAAA,EAAEvK,GAAEuK,EAAA,EACTlQ,MAAIwC,EAAAR,iBAAkBkE,EAAMP,EAC5B,OAAO3F,MAAIwC,EAAAT,QAASmE,EAAMP,iDAElB,QAAApC,GAAC2C,EAAMP,SACXwK,EAEAzB,EACM0B,oFAAAA,EAAe,QAAfA,GAAgBC,mBAEfjN,oFADV+M,EAAMX,KAAKa,yCACQ3B,EAAMlJ,aAAa6K,GAAQvP,OAAAmC,yEAApCG,GAAIkN,EAAA,QACTlN,IAASuC,GAAE,2CACJwK,GAAOxK,yCACPwK,EAAMI,QAAQnN,MAAW,GAAC,wCAC7BgN,EAAgBhN,GAAK,KAAA,4RAG9B+M,EAAMR,oFATGS,GAAeR,IAAAC,mBAAApB,KAHrB0B,KAEAzB,GAAQ1O,4BAaLoQ,EAAgBlK,GAAK,KAAA,mEAYzB,QAAAsK,GAACtK,EAAMP,GACV,GAAIoK,GAAS/P,KAAKiQ,MAAM/J,EAAMP,GAAIvC,MAClC,OAAO2M,GAAO1M,KAAO,KAAO0M,EAAOxM,6BAW7B,QAAAkN,GAACvK,EAAMP,GAAM,OAAQ3F,KAAKiQ,MAAM/J,EAAMP,GAAIvC,OAAOC,8BAS/C,QAAAsE,GAAChE,GACT3D,KAAIwC,EAAAR,iBAAkB2B,EACtB,OAAO3D,MAAIwC,EAAAxB,QAASqD,IAAIV,GAAK4C,6BAUtB,QAAAmB,GAAC/D,GACR3D,KAAIwC,EAAAR,iBAAkB2B,EACtB,OAAO3D,MAAIwC,EAAAvB,eAAgBoD,IAAIV,GAAK4C,2BAU/B,QAAAmK,GAAC/M,GAAO,MAAO3D,MAAK2H,UAAUhE,GAAO3D,KAAK0H,SAAS/D,0BAwBlD,QAAAgN,GAAC/E,MAAOgF,GAAE7N,UAAA0K,QAAA,GAAA1K,UAAA,KAAAmF,UAAE,SAAC2I,EAAGC,SAAKA,IAAE/N,UAAA,MAAGgO,GAAEhO,UAAA0K,QAAA,GAAA1K,UAAA,KAAAmF,UAAC0I,EAAE7N,UAAA,gEACrC,IAAA,GAAAiO,GAAyBpF,EAAMzD,WAAUrH,OAAAmC,YAAAgO,IAAAC,GAAAD,EAAAD,EAAA5N,QAAAC,MAAA6N,EAAA,KAAE,uBAAjCvN,GAAGwN,EAAA,MAAE5N,GAAK4N,EAAA,EACnBnR,MAAK+D,UAAUJ,EAAKiN,EAAG5Q,KAAKwG,YAAY7C,GAAMJ,EAAOI,2IAEtD,IAAA,GAAAyN,GAAyBxF,EAAMlD,QAAO5H,OAAAmC,YAAAoO,IAAAC,GAAAD,EAAAD,EAAAhO,QAAAC,MAAAiO,EAAA,KAAE,uBAA9B3N,GAAG4N,EAAA,MAAEhO,GAAKgO,EAAA,EACnBvR,MAAKmH,QAAQxD,EAAKoN,EAAG/Q,KAAKgI,UAAUrE,GAAMJ,EAAOI,kGAElD0K,MAAArO,KAAA+C,gCAgBI,QAAAyO,QAACC,GAAG1O,UAAA0K,QAAA,GAAA1K,UAAA,KAAAmF,UAAE,SAAAiH,SAAGA,IAACpM,UAAA,MAAG2O,GAAG3O,UAAA0K,QAAA,GAAA1K,UAAA,KAAAmF,UAACuJ,EAAG1O,UAAA,qBACxB,GAAIgN,GAAS,GAAIxN,EACjBwN,GAAOY,QAAQ3Q,KAAM,SAAC6Q,EAAIC,SAAOW,GAAIX,IAAK,SAACD,EAAIC,SAAOY,GAAIZ,IAC1D,OAAOf,IACP1B,MAAArO,KAAA+C,8CAgBkB,QAAA4O,GAACF,EAAKC,GAExB,GAAI3B,GAAS/P,KAAKwR,MAAMC,EAAKC,8CAC7B,IAAA,GAAAE,GAAgB5R,KAAKmI,WAAUrH,OAAAmC,YAAA4O,IAAAC,GAAAD,EAAAD,EAAAxO,QAAAC,MAAAyO,EAAA,KAAA,uBAArBpE,GAACqE,EAAA,8CACV,IAAA,GAAAC,GAAgBhS,KAAKmI,WAAUrH,OAAAmC,YAAAgP,IAAAC,GAAAD,EAAAD,EAAA5O,QAAAC,MAAA6O,EAAA,KAAA,uBAArBvE,GAACwE,EAAA,EACV,IAAIpC,EAAO7I,QAAQwG,EAAGC,GAAE,4CACvB,IAAA,GAAAyE,GAAgBpS,KAAKmI,WAAUrH,OAAAmC,YAAAoP,IAAAC,GAAAD,EAAAD,EAAAhP,QAAAC,MAAAiP,EAAA,KAAA,uBAArBC,GAACC,EAAA,EACV,IAAIzC,EAAOU,QAAQ9C,EAAG4E,GACrBxC,EAAOlK,WAAW6H,EAAG6E,0RAC1B,MAAOxC,gCAkBK,QAAA0C,uEAAiB1P,UAAA,MAAd2P,GAAOC,EAAPD,OAEf,KAAKA,EAAS,CAAEA,EAAS,iBAAI,QAI7B,GAAIE,GAAU,GAAIlQ,QACjBmQ,OAAAC,EAAI9S,KAAKmI,aACP4K,OAAO,SAACC,WAAAA,EAAU,MAATrP,GAAGsP,EAAA,MAAEC,GAAGD,EAAA,SAAME,GAAKxL,UAAUhE,KAAS,GAAKwP,EAAKzL,SAAS/D,KAAS,GAAK+O,EAAQ/O,EAAKuP,KAC7FtD,IAAI,SAACwD,WAAAA,EAAK,MAAJzP,GAAG0P,EAAA,SAAM1P,KAIlB,wCACC,GAAI2P,GAAoB,GAAI5Q,QAAImQ,OAAAC,EAAIK,EAAKhL,aAAYyH,IAAI,SAAC2D,WAAAA,EAAK,MAAJ5P,GAAG6P,EAAA,SAAI7P,KAClE,IAAM8P,GAAkB,QAAlBA,GAAmB9P,GACxB,IAAK2P,EAAkBnP,IAAIR,GAAM,CAAE,OACnC2P,EAAiB,UAAQ3P,8CACzB,IAAA,GAAA+P,GAAmBP,EAAK3N,aAAa7B,GAAI7C,OAAAmC,YAAA0Q,IAAAC,GAAAD,EAAAD,EAAAtQ,QAAAC,MAAAuQ,EAAA,KAAE,uBAAjCxQ,GAAIyQ,EAAA,EAA+BJ,GAAgBrQ,0IAC7D,IAAA,GAAA0Q,GAAmBX,EAAKpN,WAAapC,GAAI7C,OAAAmC,YAAA8Q,IAAAC,GAAAD,EAAAD,EAAA1Q,QAAAC,MAAA2Q,EAAA,KAAE,uBAAjC5Q,GAAI6Q,EAAA,EAA+BR,GAAgBrQ,gIAE9D,IAAA8Q,EAAgBtB,EAAO9R,OAAAmC,cAAAkR,GAAAC,EAAAF,EAAA9Q,QAAAC,MAAA8Q,EAAA,KAAE,IAAhBxQ,GAAGyQ,EAAA7Q,KAAekQ,GAAgB9P,+FAC3C,GAAI2P,EAAkB/M,KAAO,EAAG,CAC/B,GAAI8N,GAAcf,EAAkBgB,SAASlR,OAAOG,MACnDuM,KACAO,EAAcgE,CACf,GAAG,CACFvE,EAAMN,KAAKa,EACXA,GAAU8C,EAAK3N,aAAa6K,GAASjN,OAAOG,MAAM,SAC1C8M,IAAYgE,EACrB,MAAM,IAAI9R,GAAMgS,qBAAqBzE,QAKvC,GAAI0E,GAAoB,GAAI/R,IAG5B,IAAMgS,GAAY,QAAZA,GAAaC,EAAOtR,EAAMuR,GAE/B,GAAMC,GAAe,QAAfA,QAAgBC,GAAI9R,UAAA0K,QAAA,GAAA1K,UAAA,KAAAmF,UAAGwM,EAAK3R,UAAA,MAAE+R,GAAG/R,UAAA0K,QAAA,GAAA1K,UAAA,KAAAmF,UAAG9E,EAAIL,UAAA,SAAK4R,IAAaG,EAAKD,IAASA,EAAMC,GACpF,IAAMC,GAAe,QAAfA,GAAgB5F,SAAMwF,GAAYxB,EAAKpN,WAAWoJ,GAAKgE,EAAK3N,aAAa2J,GAG/E,IAAI6F,GAAmB,GAAItS,IAC3B,IAAIuS,GAAmB,GAAIvS,IAC3B,IAAI8N,GAAO,GAAK2C,GAAK+B,WAGrB1E,GAAKzM,UAAU2Q,EAAOvB,EAAK3M,YAAYkO,GACvClE,GAAKzM,UAAUX,EAAO+P,EAAK3M,YAAYpD,GACvCoN,GAAK/J,WAAU4H,MAAfmC,EAAIsC,EAAe8B,KAAQ/B,QAAEM,EAAKnL,UAASqG,MAAA8E,EAAAL,EAAI8B,QAC/CK,GAAc3Q,IAAIsQ,IAGlB,IAAIvE,GAAOnI,SACX,QAAQ0K,EAAQzO,IAAIf,GAAO,QACPA,EAAM2R,EAAa3R,GAAMA,OAAOG,MAAM,GAAxD8M,GAAO8E,EAAA,EAAE/R,GAAI+R,EAAA,EACd3E,GAAKzM,UAAUX,EAAM+P,EAAK3M,YAAYpD,GACtCoN,GAAK/J,WAAU4H,MAAfmC,EAAIsC,EAAe8B,EAAOvE,EAASjN,IAAKyP,QAAEM,EAAKnL,UAASqG,MAAA8E,EAAAL,EAAI8B,EAAOvE,EAASjN,OAC5E4R,GAAiB1Q,IAAI+L,EACrB4E,GAAc3Q,IAAIsQ,EAAOvE,EAASjN,IAInC,IAAKoR,EAAkBnQ,IAAIuQ,IAAS,IAAsB,CAAEJ,EAAkBpQ,IAAIwQ,IAAS,GAAI,GAAInS,MACnG,IAAK+R,EAAkBnQ,IAAIuQ,IAAS,IAAIvQ,IAAIuQ,IAAS,IAAK,CAAEJ,EAAkBnQ,IAAIuQ,IAAS,IAAIxQ,IAAIwQ,IAAS,GAAI,GAAKzB,GAAK+B,aAC1HV,EAAkBnQ,IAAIuQ,IAAS,IAAIvQ,IAAIuQ,IAAS,IAAIjE,QAAQH,8CAG5D,IAAA,GAAA4E,GAAgBH,EAAanU,OAAAmC,YAAAoS,IAAAC,GAAAD,EAAAD,EAAAhS,QAAAC,MAAAiS,EAAA,KAAK,IAAzB3R,GAAG0R,EAAA9R,KAAwB4P,GAAK3L,mBAAkB6G,MAAA8E,EAAAL,EAAInP,2IAC/D,IAAA,GAAA4R,GAAgBP,EAAgBlU,OAAAmC,YAAAuS,IAAAC,GAAAD,EAAAD,EAAAnS,QAAAC,MAAAoS,EAAA,KAAE,IAAzB9R,GAAG6R,EAAAjS,KAAwB4P,GAAK7N,sBAAsB3B,4IAIhE,IAAA,GAAA+R,GAAkB9C,EAAO9R,OAAAmC,YAAA0S,IAAAC,GAAAD,EAAAD,EAAAtS,QAAAC,MAAAuS,EAAA,KAAE,IAAlBC,GAAKF,EAAApS,iDACb,IAAA,GAAAuS,GAAmB9V,KAAKwF,aAAaqQ,GAAM/U,OAAAmC,YAAA8S,IAAAC,GAAAD,EAAAD,EAAA1S,QAAAC,MAAA2S,EAAA,KAAE,uBAAnC5S,GAAI6S,EAAA,EAAiCxB,GAAUoB,EAAOzS,EAAM,8IACtE,IAAA,GAAA8S,GAAmBlW,KAAK+F,WAAa8P,GAAM/U,OAAAmC,YAAAkT,IAAAC,GAAAD,EAAAD,EAAA9S,QAAAC,MAAA+S,EAAA,KAAE,uBAAnChT,GAAIiT,EAAA,EAAiC5B,GAAUoB,EAAOzS,EAAM;oOAIvE,IAAA,GAAAkT,GAA0B9B,EAAiB1T,OAAAmC,YAAAsT,IAAAC,GAAAD,EAAAD,EAAAlT,QAAAC,MAAAmT,EAAA,KAAA,uBAAjCtQ,GAAIuQ,EAAA,MAAEC,GAAKD,EAAA,8CACpB,IAAA,GAAAE,GAAiCD,EAAK5V,OAAAmC,YAAA2T,IAAAC,GAAAD,EAAAD,EAAAvT,QAAAC,MAAAwT,EAAA,KAAA,uBAA5BlR,GAAEmR,EAAA,MAAEC,GAAcD,EAAA,EAC3B9W,MAAKyG,WAAWP,EAAMP,EAAIoR,4NAQZ,QAAAxT,2CAAI8F,EAAIzG,MAAAoU,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAA,CAAJ5N,EAAI4N,GAAAlU,UAAAkU,GACxB,GAAIC,GAAkB7N,EAAK0J,OAAO,SAAAoE,UAAMC,EAAKjS,UAAUgS,IACvD,IAAID,EAAgBzJ,OAAQ,CAAE,KAAA,KAAA4J,EAAAhJ,MAAU9L,EAAM+U,sBAAoB,MAAAzE,OAAAC,EAAIoE,4CAGhD,QAAA3T,2CAAI8F,EAAIzG,MAAA2U,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAA,CAAJnO,EAAImO,GAAAzU,UAAAyU,GAC9B,GAAIC,GAAkBpO,EAAK0J,OAAO,SAAAoE,SAAKO,GAAKvS,UAAUgS,IACtD,IAAIM,EAAgBhK,OAAQ,CAC3B,KAAA,KAAA4J,EAAAhJ,MAAU9L,EAAMoV,mBAAiB,MAAA9E,OAAAC,EAAI2E,EAAgB7H,IAAI,SAAAjM,SAAO+T,GAAK5S,OAAOnB,sCAIhE,QAAAJ,2CAAI8F,EAAIzG,MAAAgV,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAA,CAAJxO,EAAIwO,GAAA9U,UAAA8U,GACrB,GAAIC,GAAczO,EAAK0J,OAAO,SAAAoE,UAAMY,EAAK7Q,QAAOmH,MAAA0J,EAAAjF,EAAIqE,KACpD,IAAIW,EAAYrK,OAAQ,CACvB,KAAA,KAAA4J,EAAAhJ,MAAU9L,EAAMyV,oBAAkB,MAAAnF,OAAAC,EAAIgF,yCAIpB,QAAAvU,2CAAI8F,EAAIzG,MAAAqV,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAA,CAAJ7O,EAAI6O,GAAAnV,UAAAmV,GAC3B,GAAIC,GAAe9O,EAAK0J,OAAO,SAAAoE,SAAKiB,GAAKlR,QAAOmH,MAAA+J,EAAAtF,EAAIqE,KACpD,IAAIgB,EAAa1K,OAAQ,CACxB,KAAA,KAAA4J,EAAAhJ,MAAU9L,EAAM8V,iBAAe,MAAAxF,OAAAC,EAAIqF,EAAavI,IAAI,SAAAjM,SAAOyU,GAAKzR,KAAKhD,iDAI9C,QAAAJ,GAACI,GACzB,GAAI+E,iDACJ,IAAA,GAAA4P,GAAmBtY,KAAKwF,aAAa7B,GAAI7C,OAAAmC,YAAAsV,IAAAC,GAAAD,EAAAD,EAAAlV,QAAAC,MAAAmV,EAAA,KAAE,uBAAjC7S,GAAE8S,EAAA,EAAiC/P,GAAM8G,KAAKxP,KAAK2G,KAAKhD,EAAMgC,2IACxE,IAAA,GAAA+S,GAAmB1Y,KAAK+F,WAAapC,GAAI7C,OAAAmC,YAAA0V,IAAAC,GAAAD,EAAAD,EAAAtV,QAAAC,MAAAuV,EAAA,KAAE,uBAAjC1S,GAAI2S,EAAA,EAA+BnQ,GAAM8G,KAAKxP,KAAK2G,KAAKT,EAAMvC,gGACxE,GAAI+E,EAAM+E,OAAQ,CAAE,KAAA,KAAA4J,EAAAhJ,MAAU9L,EAAMuW,wBAAsB,MAAAjG,QAAClP,GAAQ+E,uCAzxC5C,QAAAnF,GAAC2L,EAAG6J,GAC3B,MAAOnW,OAAMiB,QAAQqL,GAAKA,GAAKA,EAAG6J,oCAGT,QAAAxV,GAAC2L,EAAG6J,EAAGtY,GAChC,GAAImC,MAAMiB,QAAQqL,GAAI,mBAAkBA,IAAG6J,GAAlB7J,GAAC8J,EAAA,EAAED,GAACC,EAAA,EAAEvY,GAACuY,EAAA,GAChC,GAAIpW,MAAMiB,QAAQqL,GAAI,mBAAkBA,IAAG6J,GAAlB7J,GAAC+J,EAAA,EAAEF,GAACE,EAAA,EAAExY,GAACwY,EAAA,GAChC,OAAQ/J,EAAG6J,EAAGtY,yBAcF,QAAAyY,GAACC,EAAMC,EAAQC,GAC3B,SAAWF,KAAS,kBAAqBA,GAAKA,OAAS,SAAU,QACrCA,EAAKA,KAAMA,EAAMC,EAA3CD,GAAIG,EAAA,EAAEF,GAAME,EAAA,EAAED,GAAOC,EAAA,GAEvB,SAAWH,KAAS,SAAU,CAC7B,SAAWC,KAAW,WAAY,CACjC/W,OAAOC,OAAOtC,KAAKuZ,UAASC,KAC1BL,EAAK,sCAAIM,EAAI7W,MAAA8W,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAA,CAAJF,EAAIE,GAAA5W,UAAA4W,GACb,MAAOP,GAAO/K,MAAMgL,GAAUrZ,MAAI6S,OAAK4G,WAGnC,CACNzZ,KAAKuZ,UAAUJ,GAAQC,OAElB,IACDQ,GAAiBT,KAAZU,GAAkBT,6CAC5B,IAAA,GAAAU,GAAiBzX,OAAOgH,KAAKuQ,GAAI9Y,OAAAmC,YAAA8W,IAAAC,GAAAD,EAAAD,EAAA1W,QAAAC,MAAA2W,EAAA,KAAE,IAA1BC,GAAIF,EAAAxW,KACZvD,MAAKkZ,OAAOe,EAAML,EAAIK,GAAOJ,GAAWD,2GA/EvBrX,mBAAAA,CAi1CrBA,GAAMoV,kBAAiB,SAAAuC,KAASvC,EAAiBuC,EACrC,SADoBvC,YAAAA,EAE9BwC,GAAA9X,OAAA+X,eAF8BzC,EAAiB4B,WAAA,cAAAvZ,MAAAO,KAAAP,iCACjCmI,EAAQvF,MAAAyX,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAA,CAARnS,EAAQmS,GAAAvX,UAAAuX,GAUtBta,KAAKmI,SAAW,GAAIzF,KAAIyF,EACxBnI,MAAKua,QAAO,mBACXva,KAAKmI,SAAS5B,OAAS,EAAI,WAAa,YAAU,QAElDsM,OAAAC,EAAI9S,KAAKmI,WAAUyH,IAAI,SAAC4K,WAAAA,EAAK,MAAJ7W,GAAG8W,EAAA,SAAM9W,KAAK+W,KAAI,QAAQ,UAftB/C,IAA0BgD,MAyB1DpY,GAAM+U,qBAAoB,SAAAsD,KAAStD,EAAoBsD,EAC3C,SADuBtD,YAAAA,EAEjC6C,GAAA9X,OAAA+X,eAFiC9C,EAAoBiC,WAAA,cAAAvZ,MAAAO,KAAAP,iCACvCqJ,EAAIzG,MAAAiY,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAA,CAAJzR,EAAIyR,GAAA/X,UAAA+X,GAUlB9a,KAAKmI,SAAW,GAAIzF,KAAI2G,EACxBrJ,MAAKua,QAAO,6BACXva,KAAKmI,SAAS5B,OAAS,EAAI,WAAa,YAAU,QAElDsM,OAAAC,EAAI9S,KAAKmI,WAAUuS,KAAI,QAAQ,UAfCpD,IAA6BqD,MAyBhEpY,GAAM8V,gBAAe,SAAA0C,KAAS1C,EAAe0C,EACjC,SADkB1C,YAAAA,EAE5B8B,GAAA9X,OAAA+X,eAF4B/B,EAAekB,WAAA,cAAAvZ,MAAAO,KAAAP,iCAC7B0I,EAAK9F,MAAAoY,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAA,CAALvS,EAAKuS,GAAAlY,UAAAkY,GAUnBjb,KAAK0I,MAAQ,GAAIhG,KAAIgG,EACrB1I,MAAKua,QAAO,mBACXva,KAAK0I,MAAMnC,OAAS,EAAI,UAAY,SAAO,OAE3CsM,OAAAC,EAAI9S,KAAK0I,QAAOkH,IAAI,SAACsL,WAAAA,EAAK,MAAJvX,GAAGwX,EAAA,aAAUxX,EAAG,MAAK+W,KAAI,YAfpBrC,IAAwBsC,MAyBtDpY,GAAMyV,mBAAkB,SAAAoD,KAASpD,EAAkBoD,EACvC,SADqBpD,YAAAA,EAE/BmC,GAAA9X,OAAA+X,eAF+BpC,EAAkBuB,WAAA,cAAAvZ,MAAAO,KAAAP,iCACnC0I,EAAK9F,MAAAyY,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAA,CAAL5S,EAAK4S,GAAAvY,UAAAuY,GAUnBtb,KAAK0I,MAAQ,GAAIhG,KAAIgG,EACrB1I,MAAKua,QAAO,6BACXva,KAAK0I,MAAMnC,OAAS,EAAI,UAAY,SAAO,OAE3CsM,OAAAC,EAAI9S,KAAK0I,QAAOkH,IAAI,SAAC2L,WAAAA,EAAK,MAAJ5X,GAAG6X,EAAA,aAAU7X,EAAG,MAAK+W,KAAI,YAfjB1C,IAA2B2C,MAyB5DpY,GAAMuW,uBAAsB,SAAA2C,KAAS3C,EAAsB2C,EAC/C,SADyB3C,GACxBnV,UADwBmV,8BAChBpQ,EAAK9F,MAAA8Y,EAAA,EAAAA,EAAA,EAAA,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAA,CAALjT,EAAKiT,EAAA,GAAA5Y,UAAA4Y,GACxBxB,EAAA9X,OAAA+X,eAFmCtB,EAAsBS,WAAA,cAAAvZ,MAAAqO,MAAArO,KAEhD0I,EAST1I,MAAK8E,OAASnB,CACd3D,MAAKua,QAAO,QAAW5W,EAAG,2BACzB3D,KAAK0I,MAAMnC,OAAS,EAAI,UAAY,SAAO,OAE3CsM,OAAAC,EAAI9S,KAAK0I,QAAOkH,IAAI,SAACgM,WAAAA,EAAK,MAAJjY,GAAGkY,EAAA,aAAUlY,EAAG,MAAK+W,KAAI,YAfb5B,IAA+BvW,EAAM8V,gBAyB1E9V,GAAMuZ,WAAU,SAAAC,KAASD,EAAUC,EACvB,SADaD,GACZhM,UADYgM,EAEvB3B,GAAA9X,OAAA+X,eAFuB0B,EAAUvC,WAAA,cAAAvZ,MAAAO,KAAAP,KAWjCA,MAAK8P,MAAQA,CACb9P,MAAKua,QAAO,gCAAmCzK,QAZxBgM,IAAmBnB,MAqB5CpY,GAAMgS,qBAAoB,SAAAyH,KAASzH,EAAoByH,EAC3C,SADuBzH,GACtBzE,UADsByE,EAEjC4F,GAAA9X,OAAA+X,eAFiC7F,EAAoBgF,WAAA,cAAAvZ,MAAAO,KAAAP,KAE/C8P,EACN9P,MAAKua,QAAO,4CAA+CzK,QAH1ByE,IAA6BhS,EAAMuZ","file":"dist/graph.min.js","sourceRoot":"","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Graph\"] = factory();\n\telse\n\t\troot[\"Graph\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap e1864f16bde87f058b9b","//  ////////////////////////////////////////////////////////////////////////////////////////////////\n//  // Symbols for private members /////////////////////////////////////////////////////////////////\n//  ////////////////////////////////////////////////////////////////////////////////////////////////\n\nwindow.__graphjs__private__ = window.__graphjs__private__ || {};\n\nexport const _options                = window.__graphjs__private__._options                || Symbol(\"options\");\nexport const _vertices               = window.__graphjs__private__._vertices               || Symbol(\"vertices\");\nexport const _edges                  = window.__graphjs__private__._edges                  || Symbol(\"edges\");\nexport const _reverseEdges           = window.__graphjs__private__._reverseEdges           || Symbol(\"reverse edges\");\nexport const _sources                = window.__graphjs__private__._sources                || Symbol(\"sources\");\nexport const _sinks                  = window.__graphjs__private__._sinks                  || Symbol(\"sinks\");\nexport const _edgeCount              = window.__graphjs__private__._edgeCount              || Symbol(\"edge count\");\nexport const _extractTwoArgs         = window.__graphjs__private__._extractTwoArgs         || Symbol(\"extract ([a, b]) or (a, b) arguments\");\nexport const _extractThreeArgs       = window.__graphjs__private__._extractThreeArgs       || Symbol(\"extract ([[a, b], c]), ([a, b], c) or (a, b, c) arguments\");\nexport const _listeners              = window.__graphjs__private__._listeners              || Symbol(\"listeners\");\nexport const _trigger                = window.__graphjs__private__._trigger                || Symbol(\"trigger\");\nexport const _verticesFrom           = window.__graphjs__private__._verticesFrom           || Symbol(\"vertices from\");\nexport const _verticesTo             = window.__graphjs__private__._verticesTo             || Symbol(\"vertices to\");\nexport const _edgesFrom              = window.__graphjs__private__._edgesFrom              || Symbol(\"edges from\");\nexport const _edgesTo                = window.__graphjs__private__._edgesTo                || Symbol(\"edges to\");\nexport const _verticesWithPathTo     = window.__graphjs__private__._verticesWithPathTo     || Symbol(\"vertices with path to\");\nexport const _verticesWithPathFrom   = window.__graphjs__private__._verticesWithPathFrom   || Symbol(\"vertices with path from\");\nexport const _paths                  = window.__graphjs__private__._paths                  || Symbol(\"paths\");\nexport const _expectVertices         = window.__graphjs__private__._expectVertices         || Symbol(\"expect vertices\");\nexport const _expectVerticesAbsent   = window.__graphjs__private__._expectVerticesAbsent   || Symbol(\"expect vertex absent\");\nexport const _expectEdges            = window.__graphjs__private__._expectEdges            || Symbol(\"expect edge\");\nexport const _expectEdgesAbsent      = window.__graphjs__private__._expectEdgesAbsent      || Symbol(\"expect edge absent\");\nexport const _expectNoConnectedEdges = window.__graphjs__private__._expectNoConnectedEdges || Symbol(\"expect no connected edges\");\n\nObject.assign(window.__graphjs__private__, {\n\t_options,\n\t_vertices,\n\t_edges,\n\t_reverseEdges,\n\t_sources,\n\t_sinks,\n\t_edgeCount,\n\t_extractTwoArgs,\n\t_extractThreeArgs,\n\t_listeners,\n\t_trigger,\n\t_verticesFrom,\n\t_verticesTo,\n\t_edgesFrom,\n\t_edgesTo,\n\t_verticesWithPathTo,\n\t_verticesWithPathFrom,\n\t_paths,\n\t_expectVertices,\n\t_expectVerticesAbsent,\n\t_expectEdges,\n\t_expectEdgesAbsent,\n\t_expectNoConnectedEdges\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/private.es6.js","import {\n\t_options,\n\t_vertices, _edges, _reverseEdges, _sources, _sinks, _edgeCount, _listeners,\n\t_extractTwoArgs, _extractThreeArgs, _trigger,\n\t_verticesFrom, _verticesTo, _edgesFrom, _edgesTo,\n\t_verticesWithPathTo, _verticesWithPathFrom, _paths,\n\t_expectVertices, _expectVerticesAbsent, _expectEdges, _expectEdgesAbsent,_expectNoConnectedEdges\n} from './private.es6.js';\n\n//  ////////////////////////////////////////////////////////////////////////////////////////////////\n//  // JSDoc stuff /////////////////////////////////////////////////////////////////////////////////\n//  ////////////////////////////////////////////////////////////////////////////////////////////////\n\n/**\n * an object conforming to the {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol|ES6 iterator protocol};\n * Note that ES6 offers nice syntax for dealing with iterators.\n * @typedef {Object} Iterator\n * @property {function(): { done: boolean, value: * }} next - a zero arguments function that returns an object `{ done, value }`\n *                                                            <ul><li>If `done === false`, then `value` is the next value in the iterated sequence.</li>\n *                                                                <li>If `done === true`, the iterator is past the end of the iterated sequence.   </li></ul>\n */\n\n//  ////////////////////////////////////////////////////////////////////////////////////////////////\n//  // Graph class /////////////////////////////////////////////////////////////////////////////////\n//  ////////////////////////////////////////////////////////////////////////////////////////////////\n\n/**\n * @class Graph\n * @classdesc The main class of this library, to be used for representing a mathematical (di)graph.\n *\n * @description Constructor arguments can be used to supply initial vertices and edges.\n * @param parts {...Array}\n *        a short notation for vertices and edges to initially add to the graph;\n *        A vertex should be an array of the form `[key, value]`.\n *        An edge should be an array of the form `[[from, to], value]`.\n *        Later values of vertices or edges in this list will overwrite earlier\n *        values, but vertices need not precede their edges. Vertices that are\n *        connected but store no value need not be listed at all.\n * @example\n * var map = new Graph(\n *     ['Amsterdam',             { population: 825000 }], // vertex\n *     ['Leiden',                { population: 122000 }], // vertex\n *     [['Amsterdam', 'Leiden'], { distance:   \"40km\" }]  // edge\n * );\n */\nexport default class Graph {\n\n\tconstructor(...parts) {\n\t\t/* storage */\n\t\tthis[_vertices]     = new Map(); // Map.< string, * >\n\t\tthis[_edges]        = new Map(); // Map.< string, Map.<string, *> >\n\n\t\t/* bookkeeping */\n\t\tthis[_reverseEdges] = new Map(); // Map.< string, Set.<*> >\n\t\tthis[_sources]      = new Set(); // Set.< string >\n\t\tthis[_sinks]        = new Set(); // Set.< string >\n\t\tthis[_edgeCount]    = 0;\n\n\t\t/* listeners */\n\t\tthis[_listeners] = new Map();\n\n\t\t/* graph options */\n\t\tthis[_options] = {};\n\t\tfor (let part of parts) {\n\t\t\tif (!(part instanceof Array) && part instanceof Object) {\n\t\t\t\tObject.assign(this[_options], part);\n\t\t\t}\n\t\t}\n\n\t\t/* add vertices and values from constructor arguments */\n\t\tfor (let part of parts) {\n\t\t\tif (part instanceof Array) {\n\t\t\t\tlet [key, value] = part;\n\t\t\t\tif (Array.isArray(key)) {/////////////// an edge\n\t\t\t\t\tthis.createEdge(key, value);\n\t\t\t\t} else {//////////////////////////////// a vertex\n\t\t\t\t\tthis.addVertex(key, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t////////////////////////////////////////////////////////\n\t////////// Static private convenience methods //////////\n\t////////////////////////////////////////////////////////\n\n\tstatic [_extractTwoArgs](a, b) {\n\t\treturn Array.isArray(a) ? a : [a, b];\n\t}\n\n\tstatic [_extractThreeArgs](a, b, c) {\n\t\tif (Array.isArray(a)) { [a, b, c] = [...a, b] }\n\t\tif (Array.isArray(a)) { [a, b, c] = [...a, b] }\n\t\treturn [a, b, c];\n\t}\n\n\t////////////////////////////\n\t////////// Mixins //////////\n\t////////////////////////////\n\n\t/**\n\t * Install a new instance method for the `Graph` class.\n\t * @static\n\t * @param [name]    {string  } the name of the new instance method; defaults to `method.name`\n\t * @param method    {function} a function taking a graph as its first argument\n\t * @param [context] {object  } an optional object to refer to when using `this` inside the given `method`\n\t */\n\tstatic plugin(name, method, context) {\n\t\tif (typeof name === 'function' && typeof name.name === 'string') {\n\t\t\t[name, method, context] = [name.name, name, method];\n\t\t}\n\t\tif (typeof name === 'string') {\n\t\t\tif (typeof method === 'function') {\n\t\t\t\tObject.assign(this.prototype, {\n\t\t\t\t\t[name](...args) {\n\t\t\t\t\t\treturn method.apply(context, [this, ...args]);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis.prototype[name] = method; // document ability to add non-function values\n\t\t\t}\n\t\t} else {\n\t\t\tlet [obj, context] = [name, method];\n\t\t\tfor (let name of Object.keys(obj)) {\n\t\t\t\tthis.plugin(name, obj[name], context || obj);\n\t\t\t}\n\t\t}\n\t}\n\n\t/////////////////////////////////////\n\t////////// Event Handling //////////\n\t/////////////////////////////////////\n\n\t/**\n\t * Register an event handler.\n\t * @param event   {string}   the event to listen for\n\t * @param handler {Function} the function to call for each such event fired, receiving its corresponding value\n\t */\n\ton(event, handler) {\n\t\tif (!this[_listeners].has(event)) {\n\t\t\tthis[_listeners].set(event, new Set());\n\t\t}\n\t\tthis[_listeners].get(event).add(handler);\n\t}\n\n\t/**\n\t * Deregister a previously registered event handler.\n\t * @param event   {string}   the event used to originally register a handler\n\t * @param handler {Function} the handler originally registered\n\t */\n\toff(event, handler) {\n\t\tif (this[_listeners].has(event)) {\n\t\t\tthis[_listeners].get(event).delete(handler);\n\t\t}\n\t}\n\n\t[_trigger](event, value) {\n\t\tfor (let handler of this[_listeners].get(event) || []) {\n\t\t\thandler(value);\n\t\t}\n\t}\n\n\t/**\n\t * An event that is triggered just after a vertex is added to this graph.\n\t * Handlers receive the new vertex `[key, value]` as an argument.\n\t * @event vertex-added\n\t * @memberof Graph\n\t * @instance\n\t * @see {@link Graph#on}\n\t * @see {@link Graph#off}\n\t */\n\t/**\n\t * An event that is triggered just after a vertex is removed from this graph.\n\t * Handlers receive the vertex key as an argument.\n\t * @event vertex-removed\n\t * @memberof Graph\n\t * @instance\n\t * @see {@link Graph#on}\n\t * @see {@link Graph#off}\n\t */\n\t/**\n\t * An event that is triggered after a vertex in this graph is modified.\n\t * It is also triggered after any {@link #Graph#event_vertex-added|\"vertex-added\"} event.\n\t * Handlers receive the vertex `[key, value]` as an argument.\n\t * @event vertex-modified\n\t * @memberof Graph\n\t * @instance\n\t * @see {@link Graph#on}\n\t * @see {@link Graph#off}\n\t */\n\t/**\n\t * An event that is triggered just after an edge is added to this graph.\n\t * Handlers receive the new edge `[[from, to], value]` as an argument.\n\t * @event edge-added\n\t * @memberof Graph\n\t * @instance\n\t * @see {@link Graph#on}\n\t * @see {@link Graph#off}\n\t */\n\t/**\n\t * An event that is triggered just after an edge is removed from this graph.\n\t * Handlers receive the edge key `[from, to]` as an argument.\n\t * @event edge-removed\n\t * @memberof Graph\n\t * @instance\n\t * @see {@link Graph#on}\n\t * @see {@link Graph#off}\n\t */\n\t/**\n\t * An event that is triggered after an edge in this graph is modified.\n\t * It is also triggered after any {@link #Graph#event_edge-added|\"edge-added\"} event.\n\t * Handlers receive the edge `[[from, to], value]` as an argument.\n\t * @event edge-modified\n\t * @memberof Graph\n\t * @instance\n\t * @see {@link Graph#on}\n\t * @see {@link Graph#off}\n\t */\n\n\n\t//////////////////////////////\n\t////////// Vertices //////////\n\t//////////////////////////////\n\n\t////////// creating them //////////\n\n\t/**\n\t * Add a new vertex to this graph.\n\t * @throws {Graph.VertexExistsError} if a vertex with this key already exists\n\t * @param  key    {string} the key with which to refer to this new vertex\n\t * @param [value] {*}      the value to store in this new vertex\n\t */ // TODO: allow [key, value] array to be given as argument in docs\n\taddNewVertex(key, value) {\n\t\t[key, value] = Graph[_extractTwoArgs](key, value);\n\t\tthis[_expectVerticesAbsent](key);\n\t\tthis[_vertices].set(key, value);\n\t\tthis[_edges].set(key, new Map());\n\t\tthis[_reverseEdges].set(key, new Set());\n\t\tthis[_sources].add(key);\n\t\tthis[_sinks].add(key);\n\t\tthis[_trigger]('vertex-added',    this.vertex(key));\n\t\tthis[_trigger]('vertex-modified', this.vertex(key));\n\t}\n\n\t/**\n\t * Set the value of an existing vertex in this graph.\n\t * @throws {Graph.VertexNotExistsError} if a vertex with this key does not exist\n\t * @param  key    {string} the key belonging to the vertex\n\t * @param [value] {*}      the value to store in this vertex\n\t */ // TODO: allow [key, value] array to be given as argument in docs\n\tsetVertex(key, value) {\n\t\t[key, value] = Graph[_extractTwoArgs](key, value);\n\t\tthis[_expectVertices](key);\n\t\tthis[_vertices].set(key, value);\n\t\tthis[_trigger]('vertex-modified', this.vertex(key));\n\t}\n\n\t/**\n\t * Make sure a vertex with a specific key exists in this graph. If it already exists,\n\t * do nothing. If it does not yet exist, add a new vertex with the given value.\n\t * @param  key    {string} the key for the vertex\n\t * @param [value] {*}      the value to store if a new vertex is added\n\t */ // TODO: allow [key, value] array to be given as argument in docs\n\tensureVertex(key, value) {\n\t\t[key, value] = Graph[_extractTwoArgs](key, value);\n\t\tif (!this.hasVertex(key)) {\n\t\t\tthis.addNewVertex(key, value);\n\t\t}\n\t}\n\n\t/**\n\t * Add a new vertex to this graph. If a vertex with this key already exists,\n\t * the value of that vertex is overwritten.\n\t * @param  key    {string} the key with which to refer to this new vertex\n\t * @param [value] {*}      the value to store in this new vertex\n\t */ // TODO: allow [key, value] array to be given as argument in docs\n\taddVertex(key, value) {\n\t\t[key, value] = Graph[_extractTwoArgs](key, value);\n\t\tif (this.hasVertex(key)) {\n\t\t\tthis.setVertex(key, value);\n\t\t} else {\n\t\t\tthis.addNewVertex(key, value);\n\t\t}\n\t}\n\n\n\t////////// removing them //////////\n\n\t/**\n\t * Remove an existing vertex from this graph.\n\t * @throws {Graph.VertexNotExistsError} if a vertex with this key does not exist\n\t * @throws {Graph.HasConnectedEdgesError} if there are still edges connected to this vertex\n\t * @param key {string} the key of the vertex to remove\n\t */\n\tremoveExistingVertex(key) {\n\t\tthis[_expectVertices](key);\n\t\tthis[_expectNoConnectedEdges](key);\n\t\tthis[_vertices].delete(key);\n\t\tthis[_sources].delete(key);\n\t\tthis[_sinks].delete(key);\n\t\tthis[_trigger]('vertex-removed', key);\n\t}\n\n\t/**\n\t * Remove an existing vertex from this graph, as well as all edges connected to it.\n\t * @throws {Graph.VertexNotExistsError} if a vertex with this key does not exist\n\t * @param key {string} the key of the vertex to remove\n\t */\n\tdestroyExistingVertex(key) {\n\t\tthis[_expectVertices](key);\n\t\tfor (let [to] of this.verticesFrom(key)) { this.removeEdge(key,  to ) }\n\t\tfor (let [from] of this.verticesTo(key)) { this.removeEdge(from, key) }\n\t\tthis.removeExistingVertex(key);\n\t}\n\n\t/**\n\t * Remove an existing vertex from this graph.\n\t * If a vertex with this key does not exist, nothing happens.\n\t * @throws {Graph.HasConnectedEdgesError} if there are still edges connected to this vertex\n\t * @param key {string} the key of the vertex to remove\n\t */\n\tremoveVertex(key) {\n\t\tif (this.hasVertex(key)) {\n\t\t\tthis.removeExistingVertex(key);\n\t\t}\n\t}\n\n\t/**\n\t * Remove a vertex from this graph, as well as all edges connected to it.\n\t * If a vertex with this key does not exist, nothing happens.\n\t * @param key {string} the key of the vertex to remove\n\t */\n\tdestroyVertex(key) {\n\t\tif (this.hasVertex(key)) {\n\t\t\tthis.destroyExistingVertex(key);\n\t\t}\n\t}\n\n\n\t////////// querying them //////////\n\n\t/**\n\t * @returns {number} the number of vertices in the whole graph\n\t */\n\tvertexCount() { return this[_vertices].size }\n\n\t/**\n\t * Ask whether a vertex with a given key exists.\n\t * @param key {string} the key to query\n\t * @returns {boolean} whether there is a vertex with the given key\n\t */\n\thasVertex(key) { return this[_vertices].has(key) }\n\n\t/**\n\t * Get the key/value pair representing the vertex with the given `key`.\n\t * @param key {string} the key to query\n\t * @throws {Graph.VertexNotExistsError} if the `key` vertex does not exist in the graph\n\t * @returns {Array} a `[key, value]` shaped array representing the vertex\n\t */\n\tvertex(key) {\n\t\tthis[_expectVertices](key);\n\t\treturn [key, this.vertexValue(key)];\n\t}\n\n\t/**\n\t * Get the value associated with the vertex of a given `key`.\n\t * @param key {string} the key to query\n\t * @returns {*} the value associated with the vertex of the given key.\n\t * Note that a return value of `undefined` can mean\n\t *\n\t * 1. that there is no such vertex, or\n\t * 2. that the stored value is actually `undefined`.\n\t *\n\t * Use {@link Graph#hasVertex} to distinguish these cases.\n\t */\n\tvertexValue(key) { return this[_vertices].get(key) }\n\n\n\t///////////////////////////\n\t////////// Edges //////////\n\t///////////////////////////\n\n\t////////// adding them //////////\n\n\t/**\n\t * Add a new edge to this graph.\n\t * @throws {Graph.EdgeExistsError} if an edge between `from` and `to` already exists\n\t * @throws {Graph.VertexNotExistsError} if the `from` and/or `to` vertices do not yet exist in the graph\n\t * @param  from   {string} the key for the originating vertex\n\t * @param  to     {string} the key for the terminating vertex\n\t * @param [value] {*}      the value to store in this new edge\n\t */ // TODO: allow [from, to], value array to be given as argument in docss; or [[from, to], value] as single argument\n\taddNewEdge(from, to, value) {\n\t\t[from, to, value] = Graph[_extractThreeArgs](from, to, value);\n\t\tthis[_expectEdgesAbsent]([from, to]);\n\t\tthis[_expectVertices](from, to);\n\t\tthis[_edges].get(from).set(to, value);\n\t\tthis[_reverseEdges].get(to).add(from);\n\t\tthis[_edgeCount] += 1;\n\t\tthis[_sources].delete(to);\n\t\tthis[_sinks].delete(from);\n\t\tthis[_trigger]('edge-added',    this.edge(from, to));\n\t\tthis[_trigger]('edge-modified', this.edge(from, to));\n\t}\n\n\t/**\n\t * Add a new edge to this graph. If the `from` and/or `to` vertices do not yet exist\n\t * in the graph, they are implicitly added with an `undefined` value.\n\t * @throws {Graph.EdgeExistsError} if an edge between `from` and `to` already exists\n\t * @param  from   {string} the key for the originating vertex\n\t * @param  to     {string} the key for the terminating vertex\n\t * @param [value] {*}      the value to store in this new edge\n\t */ // TODO: allow [from, to], value array to be given as argument in docss; or [[from, to], value] as single argument\n\tcreateNewEdge(from, to, value) {\n\t\t[from, to, value] = Graph[_extractThreeArgs](from, to, value);\n\t\tthis[_expectEdgesAbsent]([from, to]);\n\t\tthis.ensureVertex(from);\n\t\tthis.ensureVertex(to);\n\t\tthis.addNewEdge(from, to, value);\n\t}\n\n\t/**\n\t * Set the value of an existing edge in this graph.\n\t * @throws {Graph.EdgeNotExistsError} if an edge between `from` and `to` does not yet exist\n\t * @param  from   {string} the key for the originating vertex\n\t * @param  to     {string} the key for the terminating vertex\n\t * @param [value] {*}      the value to store in this edge\n\t */ // TODO: allow [from, to], value array to be given as argument in docss; or [[from, to], value] as single argument\n\tsetEdge(from, to, value) {\n\t\t[from, to, value] = Graph[_extractThreeArgs](from, to, value);\n\t\tthis[_expectEdges]([from, to]);\n\t\tthis[_edges].get(from).set(to, value);\n\t\tthis[_trigger]('edge-modified', this.edge(from, to));\n\t}\n\n\t/**\n\t * Make sure an edge between the `from` and `to` vertices in this graph.\n\t * If one already exists, nothing is done.\n\t * If one does not yet exist, a new edge is added with the given value.\n\t * @throws {Graph.VertexNotExistsError} if the `from` and/or `to` vertices do not yet exist in the graph\n\t * @param  from   {string} the key for the originating vertex\n\t * @param  to     {string} the key for the terminating vertex\n\t * @param [value] {*}      the value to store if a new edge is added\n\t */ // TODO: allow [from, to], value array to be given as argument in docss; or [[from, to], value] as single argument\n\tspanEdge(from, to, value) {\n\t\t[from, to, value] = Graph[_extractThreeArgs](from, to, value);\n\t\tthis[_expectVertices](from, to);\n\t\tif (!this.hasEdge(from, to)) {\n\t\t\tthis.addNewEdge(from, to, value);\n\t\t}\n\t}\n\n\t/**\n\t * Add a new edge to this graph. If an edge between `from` and `to` already exists,\n\t * the value of that edge is overwritten.\n\t * @throws {Graph.VertexNotExistsError} if the `from` and/or `to` vertices do not yet exist in the graph\n\t * @param  from   {string} the key for the originating vertex\n\t * @param  to     {string} the key for the terminating vertex\n\t * @param [value] {*}      the value to store in this new edge\n\t */ // TODO: allow [from, to], value array to be given as argument in docss; or [[from, to], value] as single argument\n\taddEdge(from, to, value) {\n\t\t[from, to, value] = Graph[_extractThreeArgs](from, to, value);\n\t\tif (this.hasEdge(from, to)) {\n\t\t\tthis.setEdge(from, to, value);\n\t\t} else {\n\t\t\tthis.addNewEdge(from, to, value);\n\t\t}\n\t}\n\n\t/**\n\t * Make sure an edge between the `from` and `to` vertices exists in this graph.\n\t * If it already exists, nothing is done.\n\t * If it does not yet exist, a new edge is added with the given value.\n\t * If the `from` and/or `to` vertices do not yet exist\n\t * in the graph, they are implicitly added with an `undefined` value.\n\t * @param  from   {string} the key for the originating vertex\n\t * @param  to     {string} the key for the terminating vertex\n\t * @param [value] {*}      the value to store if a new edge is added\n\t */ // TODO: allow [from, to], value array to be given as argument in docss; or [[from, to], value] as single argument\n\tensureEdge(from, to, value) {\n\t\t[from, to, value] = Graph[_extractThreeArgs](from, to, value);\n\t\tif (!this.hasEdge(from, to)) {\n\t\t\tthis.createNewEdge(from, to, value);\n\t\t}\n\t}\n\n\t/**\n\t * Add a new edge to this graph. If an edge between the `from` and `to`\n\t * vertices already exists, the value of that edge is overwritten.\n\t * If the `from` and/or `to` vertices do not yet exist\n\t * in the graph, they are implicitly added with an `undefined` value.\n\t * @param  from   {string} the key for the originating vertex\n\t * @param  to     {string} the key for the terminating vertex\n\t * @param [value] {*}      the value to store if a new edge is added\n\t */ // TODO: allow [from, to], value array to be given as argument in docss; or [[from, to], value] as single argument\n\tcreateEdge(from, to, value) {\n\t\t[from, to, value] = Graph[_extractThreeArgs](from, to, value);\n\t\tif (this.hasEdge(from, to)) {\n\t\t\tthis.setEdge(from, to, value);\n\t\t} else {\n\t\t\tthis.createNewEdge(from, to, value);\n\t\t}\n\t}\n\n\n\t////////// removing them //////////\n\n\t/**\n\t * Remove an existing edge from this graph.\n\t * @throws {Graph.EdgeNotExistsError} if an edge between the `from` and `to` vertices doesn't exist\n\t * @param from {string} the key for the originating vertex\n\t * @param to   {string} the key for the terminating vertex\n\t */ // TODO: allow [from, to] array to be given as argument in docs\n\tremoveExistingEdge(from, to) {\n\t\t[from, to] = Graph[_extractTwoArgs](from, to);\n\t\tthis[_expectEdges]([from, to]);\n\t\tthis[_edges].get(from).delete(to);\n\t\tthis[_reverseEdges].get(to).delete(from);\n\t\tthis[_edgeCount] -= 1;\n\t\tif (this. inDegree(to)   === 0) { this[_sources].add(to) }\n\t\tif (this.outDegree(from) === 0) { this[_sinks].add(from) }\n\t\tthis[_trigger]('edge-removed', [from, to]);\n\t}\n\n\t/**\n\t * Remove an edge from this graph.\n\t * If an edge between the `from` and `to` vertices doesn't exist, nothing happens.\n\t * @param from {string} the key for the originating vertex\n\t * @param to   {string} the key for the terminating vertex\n\t */ // TODO: allow [from, to] array to be given as argument in docs\n\tremoveEdge(from, to) {\n\t\t[from, to] = Graph[_extractTwoArgs](from, to);\n\t\tif (this.hasEdge(from, to)) {\n\t\t\tthis.removeExistingEdge(from, to);\n\t\t}\n\t}\n\n\n\t////////// querying them //////////\n\n\t/**\n\t * @returns {number} the number of edges in the whole graph\n\t */\n\tedgeCount() { return this[_edgeCount] }\n\n\t/**\n\t * Ask whether an edge between given `from` and `to` vertices exist.\n\t * @param from {string} the key for the originating vertex\n\t * @param to   {string} the key for the terminating vertex\n\t * @returns {boolean} whether there is an edge between the given `from` and `to` vertices\n\t */ // TODO: allow [from, to] array to be given as argument in docs\n\thasEdge(from, to) {\n\t\t[from, to] = Graph[_extractTwoArgs](from, to);\n\t\treturn this.hasVertex(from) &&\n\t\t\tthis.hasVertex(to) &&\n\t\t\tthis[_edges].has(from) &&\n\t\t\tthis[_edges].get(from).has(to);\n\t}\n\n\t/**\n\t * Get the key/value pair representing the edge between the given `from` and `to`.\n\t * @param from {string} the key for the originating vertex\n\t * @param to   {string} the key for the terminating vertex\n\t * @returns {Array} a `[[from, to], value]` shaped array representing the edge\n\t */ // TODO: allow [from, to] array to be given as argument in docs\n\tedge(from, to) {\n\t\t[from, to] = Graph[_extractTwoArgs](from, to);\n\t\tthis[_expectEdges]([from, to]);\n\t\treturn [[from, to], this.edgeValue(from, to)];\n\t}\n\n\t/**\n\t * Get the value associated with the edge between given `from` and `to` vertices.\n\t * @param from {string} the key for the originating vertex\n\t * @param to   {string} the key for the terminating vertex\n\t * @returns {*} the value associated with the edge between the given `from` and `to` vertices\n\t * Note that a return value of `undefined` can mean\n\t *\n\t * 1. that there is no such edge, or\n\t * 2. that the stored value is actually `undefined`.\n\t *\n\t * Use {@link Graph#hasEdge} to distinguish these cases.\n\t */ // TODO: allow [from, to] array to be given as argument in docs\n\tedgeValue(from, to) {\n\t\t[from, to] = Graph[_extractTwoArgs](from, to);\n\t\treturn this.hasEdge(from, to) ? this[_edges].get(from).get(to) : undefined;\n\t}\n\n\n\t///////////////////////////////////////////////\n\t//////////// ES6 Iterable interfaces //////////\n\t///////////////////////////////////////////////\n\n\t/**\n\t * Iterate over all vertices of the graph, in no particular order.\n\t * @returns {Iterator} an ES6 iterator yielding vertices\n\t * @example\n\t * for (var it = graph.vertices(), kv; !(kv = it.next()).done;) {\n\t *     var key   = kv.value[0],\n\t *         value = kv.value[1];\n\t *     // iterates over all vertices of the graph\n\t * }\n\t * @example\n\t * // in ECMAScript 6, you can use a for..of loop\n\t * for (let [key, value] of graph.vertices()) {\n\t *     // iterates over all vertices of the graph\n\t * }\n\t * @see {@link Graph#@@iterator}\n\t */\n\t*vertices() {\n\t\tlet done = new Set();\n\t\tfor (let [key] of this[_vertices]) {\n\t\t\tif (this.hasVertex(key) && !done.has(key)) {\n\t\t\t\tdone.add(key);\n\t\t\t\tyield this.vertex(key);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * A {@link Graph} object is itself {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol|iterable},\n\t * and serves as a short notation in ECMAScript 6 to iterate over all vertices in the graph, in no particular order.\n\t * @method Graph#@@iterator\n\t * @returns {Iterator} an ES6 iterator yielding vertices\n\t * @example\n\t * for (let [key, value] of graph) {\n\t *     // iterates over all vertices of the graph\n\t * }\n\t * @see {@link Graph#vertices}\n\t */\n\t[Symbol.iterator]() { return this.vertices() }\n\n\t/**\n\t * Iterate over all edges of the graph, in no particular order.\n\t * @returns {Iterator} an ES6 iterator yielding edges\n\t * @example\n\t * for (var it = graph.edges(), kv; !(kv = it.next()).done;) {\n\t *     var from  = kv.value[0][0],\n\t *         to    = kv.value[0][1],\n\t *         value = kv.value[1];\n\t *     // iterates over all edges of the graph\n\t * }\n\t * @example\n\t * // in ECMAScript 6, you can use a for..of loop\n\t * for (let [[from, to], value] of graph.edges()) {\n\t *     // iterates over all vertices of the graph\n\t * }\n\t */\n\t*edges() {\n\t\tlet done = new Map();\n\t\tfor (let from of this[_edges].keys()) {\n\t\t\tdone.set(from, new Set());\n\t\t\tfor (let to of this[_edges].get(from).keys()) {\n\t\t\t\tif (!done.get(from).has(to) && this.hasEdge(from, to)) {\n\t\t\t\t\tdone.get(from).add(to);\n\t\t\t\t\tyield this.edge(from, to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Iterate over the vertices directly reachable from a given vertex in the graph, in no particular order.\n\t * @throws {Graph.VertexNotExistsError} if a vertex with the given `from` key does not exist\n\t * @param key {string} the key of the vertex to take the outgoing edges from\n\t * @returns {Iterator} an ES6 iterator yielding vertices\n\t * @example\n\t * for (var it = graph.verticesFrom(from), kv; !(kv = it.next()).done;) {\n\t *     var to    = kv.value[0],\n\t *         value = kv.value[1];\n\t *     // iterates over all outgoing vertices of the `from` vertex\n\t * }\n\t * @example\n\t * // in ECMAScript 6, you can use a for..of loop\n\t * for (let [to, value] of graph.verticesFrom(from)) {\n\t *     // iterates over all outgoing vertices of the `from` vertex\n\t * }\n\t */\n\tverticesFrom(key) {\n\t\tthis[_expectVertices](key);\n\t\treturn this[_verticesFrom](key);\n\t}\n\t*[_verticesFrom](from) {\n\t\tlet done = new Set();\n\t\tfor (let to of this[_edges].get(from).keys()) {\n\t\t\tif (!done.has(to) && this.hasEdge(from, to)) {\n\t\t\t\tdone.add(to);\n\t\t\t\tyield this.vertex(to);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Iterate over the vertices from which a given vertex in the graph is directly reachable, in no particular order.\n\t * @throws {Graph.VertexNotExistsError} if a vertex with the given `to` key does not exist\n\t * @param key {string} the key of the vertex to take the incoming edges from\n\t * @returns {Iterator} an ES6 iterator yielding vertices\n\t * @example\n\t * for (var it = graph.verticesTo(to), kv; !(kv = it.next()).done;) {\n\t *     var from  = kv.value[0],\n\t *         value = kv.value[1];\n\t *     // iterates over all outgoing vertices of the `to` vertex\n\t * }\n\t * @example\n\t * // in ECMAScript 6, you can use a for..of loop\n\t * for (let [from, value] of graph.verticesTo(to)) {\n\t *     // iterates over all incoming vertices of the `to` vertex\n\t * }\n\t */\n\tverticesTo(key) {\n\t\tthis[_expectVertices](key);\n\t\treturn this[_verticesTo](key);\n\t}\n\t*[_verticesTo](to) {\n\t\tlet done = new Set();\n\t\tfor (let from of this[_reverseEdges].get(to)) {\n\t\t\tif (!done.has(from) && this.hasEdge(from, to)) {\n\t\t\t\tdone.add(from);\n\t\t\t\tyield this.vertex(from);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Iterate over the outgoing edges of a given vertex in the graph, in no particular order.\n\t * @throws {Graph.VertexNotExistsError} if a vertex with the given `from` key does not exist\n\t * @param key {string} the key of the vertex to take the outgoing edges from\n\t * @returns {Iterator} an ES6 iterator yielding edges\n\t * @example\n\t * for (var it = graph.edgesFrom(from), kv; !(kv = it.next()).done;) {\n\t *     var from  = kv.value[0][0],\n\t *         to    = kv.value[0][1],\n\t *         value = kv.value[1];\n\t *     // iterates over all outgoing edges of the `from` vertex\n\t * }\n\t * @example\n\t * // in ECMAScript 6, you can use a for..of loop\n\t * for (let [[from, to], value] of graph.edgesFrom(from)) {\n\t *     // iterates over all outgoing edges of the `from` vertex\n\t * }\n\t */\n\tedgesFrom(key) {\n\t\tthis[_expectVertices](key);\n\t\treturn this[_edgesFrom](key);\n\t}\n\t*[_edgesFrom](from) {\n\t\tlet done = new Set();\n\t\tfor (let to of this[_edges].get(from).keys()) {\n\t\t\tif (!done.has(to) && this.hasEdge(from, to)) {\n\t\t\t\tdone.add(to);\n\t\t\t\tyield this.edge(from, to);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Iterate over the incoming edges of a given vertex in the graph, in no particular order.\n\t * @throws {Graph.VertexNotExistsError} if a vertex with the given `to` key does not exist\n\t * @param key {string} the key of the vertex to take the incoming edges from\n\t * @returns {Iterator} an ES6 iterator yielding edges\n\t * @example\n\t * for (var it = graph.edgesTo(to), kv; !(kv = it.next()).done;) {\n\t *     var from  = kv.value[0][0],\n\t *         to    = kv.value[0][1],\n\t *         value = kv.value[1];\n\t *     // iterates over all incoming edges of the `to` vertex\n\t * }\n\t * @example\n\t * // in ECMAScript 6, you can use a for..of loop\n\t * for (let [[from, to], value] of graph.edgesTo(to)) {\n\t *     // iterates over all incoming edges of the `to` vertex\n\t * }\n\t */\n\tedgesTo(key) {\n\t\tthis[_expectVertices](key);\n\t\treturn this[_edgesTo](key);\n\t}\n\t*[_edgesTo](to) {\n\t\tlet done = new Set();\n\t\tfor (let from of this[_reverseEdges].get(to)) {\n\t\t\tif (!done.has(from) && this.hasEdge(from, to)) {\n\t\t\t\tdone.add(from);\n\t\t\t\tyield this.edge(from, to);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Iterate over all vertices reachable from a given vertex in the graph, in no particular order.\n\t * @throws {Graph.VertexNotExistsError} if a vertex with the given `from` key does not exist\n\t * @param from {string} the key of the vertex to take the reachable vertices from\n\t * @returns {Iterator} an ES6 iterator yielding vertices\n\t * @example\n\t * for (var it = graph.verticesWithPathFrom(from), kv; !(kv = it.next()).done;) {\n\t *     var key   = kv.value[0],\n\t *         value = kv.value[1];\n\t *     // iterates over all vertices reachable from `from`\n\t * }\n\t * @example\n\t * // in ECMAScript 6, you can use a for..of loop\n\t * for (let [key, value] of graph.verticesWithPathFrom(from)) {\n\t *     // iterates over all vertices reachable from `from`\n\t * }\n\t */\n\tverticesWithPathFrom(from) {\n\t\tthis[_expectVertices](from);\n\t\treturn this[_verticesWithPathFrom](from, new Set());\n\t}\n\t*[_verticesWithPathFrom](from, done) {\n\t\tfor (let [to] of this.verticesFrom(from)) {\n\t\t\tif (!done.has(to) && this.hasEdge(from, to)) {\n\t\t\t\tdone.add(to);\n\t\t\t\tyield this.vertex(to);\n\t\t\t\tyield* this[_verticesWithPathFrom](to, done);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Iterate over all vertices from which a given vertex in the graph can be reached, in no particular order.\n\t * @throws {Graph.VertexNotExistsError} if a vertex with the given `to` key does not exist\n\t * @param to {string} the key of the vertex to take the reachable vertices from\n\t * @returns {Iterator} an ES6 iterator yielding vertices\n\t * @example\n\t * for (var it = graph.verticesWithPathTo(to), kv; !(kv = it.next()).done;) {\n\t *     var key   = kv.value[0],\n\t *         value = kv.value[1];\n\t *     // iterates over all vertices from which `to` can be reached\n\t * }\n\t * @example\n\t * // in ECMAScript 6, you can use a for..of loop\n\t * for (let [key, value] of graph.verticesWithPathTo(to)) {\n\t *     // iterates over all vertices from which `to` can be reached\n\t * }\n\t */\n\tverticesWithPathTo(to) {\n\t\tthis[_expectVertices](to);\n\t\treturn this[_verticesWithPathTo](to, new Set());\n\t}\n\t*[_verticesWithPathTo](to, done) {\n\t\tfor (let [from] of this.verticesTo(to)) {\n\t\t\tif (!done.has(from) && this.hasEdge(from, to)) {\n\t\t\t\tdone.add(from);\n\t\t\t\tyield this.vertex(from);\n\t\t\t\tyield* this[_verticesWithPathTo](from, done);\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Iterate over all vertices that have no incoming edges, in no particular order.\n\t * @returns {Iterator} an ES6 iterator yielding vertices\n\t * @example\n\t * for (var it = graph.sources(), kv; !(kv = it.next()).done;) {\n\t *     var key   = kv.value[0],\n\t *         value = kv.value[1];\n\t *     // iterates over all vertices with no incoming edges\n\t * }\n\t * @example\n\t * // in ECMAScript 6, you can use a for..of loop\n\t * for (let [key, value] of graph.sources()) {\n\t *     // iterates over all vertices with no incoming edges\n\t * }\n\t */\n\t*sources() {\n\t\tlet done = new Set();\n\t\tfor (let key of this[_sources]) {\n\t\t\tif (this.hasVertex(key) && !done.has(key)) {\n\t\t\t\tdone.add(key);\n\t\t\t\tyield this.vertex(key);\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Iterate over all vertices that have no outgoing edges, in no particular order.\n\t * @returns {Iterator} an ES6 iterator yielding vertices\n\t * @example\n\t * for (var it = graph.sinks(), kv; !(kv = it.next()).done;) {\n\t *     var key   = kv.value[0],\n\t *         value = kv.value[1];\n\t *     // iterates over all vertices with no outgoing edges\n\t * }\n\t * @example\n\t * // in ECMAScript 6, you can use a for..of loop\n\t * for (let [key, value] of graph.sinks()) {\n\t *     // iterates over all vertices with no outgoing edges\n\t * }\n\t */\n\t*sinks() {\n\t\tlet done = new Set();\n\t\tfor (let key of this[_sinks]) {\n\t\t\tif (this.hasVertex(key) && !done.has(key)) {\n\t\t\t\tdone.add(key);\n\t\t\t\tyield this.vertex(key);\n\t\t\t}\n\t\t}\n\t}\n\n\n\t////////////////////////////////////////\n\t////////// Setting & Clearing //////////\n\t////////////////////////////////////////\n\n\n\t/**\n\t * Set this graph to become equal to another graph, so that it has\n\t * all the same vertices and edges. It emits only those signals\n\t * that are strictly necessary.\n\t * @param other {Graph} the graph copy to this graph\n\t */\n\tset(other) {\n\t\tfor (let [key, value] of this.edges()) {\n\t\t\tif (!other.hasEdge(key)) {\n\t\t\t\tthis.removeExistingEdge(key);\n\t\t\t} else if (value !== other.edgeValue(key)) {\n\t\t\t\tthis.setEdge(key, other.edgeValue(key));\n\t\t\t}\n\t\t}\n\t\tfor (let [key, value] of this.vertices()) {\n\t\t\tif (!other.hasVertex(key)) {\n\t\t\t\tthis.removeExistingVertex(key);\n\t\t\t} else if (value !== other.vertexValue(key)) {\n\t\t\t\tthis.setVertex(key, other.vertexValue(key));\n\t\t\t}\n\t\t}\n\t\tfor (let [key, value] of other.vertices()) {\n\t\t\tif (!this.hasVertex(key)) {\n\t\t\t\tthis.addNewVertex(key, value);\n\t\t\t}\n\t\t}\n\t\tfor (let [key, value] of other.edges()) {\n\t\t\tif (!this.hasEdge(key)) {\n\t\t\t\tthis.addNewEdge(key, value);\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Remove all edges from the graph, but leave the vertices intact.\n\t */\n\tclearEdges() {\n\t\tfor (let [key] of this.edges()) { this.removeEdge(key) }\n\t}\n\n\t/**\n\t * Remove all edges and vertices from the graph, putting it back in its initial state.\n\t */\n\tclear() {\n\t\tfor (let [key] of this.vertices()) { this.destroyVertex(key) }\n\t}\n\n\n\t////////////////////////////////////////\n\t////////// (Advanced) Queries //////////\n\t////////////////////////////////////////\n\n\n\t/**\n\t * Ask whether `this` graph and a given `other` graph are equal.\n\t * Two graphs are equal if they have the same vertices and the same edges.\n\t * @param other {Graph} the other graph to compare to `this` one\n\t * @param [eqV] {function(*, *, string): boolean}\n\t *     a custom equality function for values stored in vertices;\n\t *     defaults to `===` comparison; The first two arguments are the\n\t *     values to compare. The third is the corresponding `key`.\n\t * @param [eqE] {function(*, *, Array): boolean}\n\t *     a custom equality function for values stored in edges;\n\t *     defaults to the function given for `eqV`; The first two arguments\n\t *     are the values to compare. The third is the corresponding\n\t *     `[from, to]` key.\n\t * @returns {boolean} `true` if the two graphs are equal; `false` otherwise\n\t */\n\tequals(other, eqV=(x,y)=>(x===y), eqE=eqV) {\n\t\tif (!(other instanceof Graph))                  { return false }\n\t\tif (this.vertexCount() !== other.vertexCount()) { return false }\n\t\tif (this.edgeCount()   !== other.edgeCount()  ) { return false }\n\t\tfor (let [key, value] of this.vertices()) {\n\t\t\tif (!other.hasVertex(key))                    { return false }\n\t\t\tif (!eqV(value, other.vertexValue(key), key)) { return false }\n\t\t}\n\t\tfor (let [key, value] of this.edges()) {\n\t\t\tif (!other.hasEdge(key))                      { return false }\n\t\t\tif (!eqE(value, other.edgeValue(key), key))   { return false }\n\t\t}\n\t\treturn true;\n\t}\n\n\n\t/**\n\t * Iterate over all simple directed cycles in this graph, in no particular order.\n\t * If you mutate the graph in between iterations, behavior of the iterator\n\t * becomes unspecified. (So, don't.)\n\t * @returns {Iterator} an ES6 iterator yielding arrays containing the vertex keys describing a cycle;\n\t *                     These arrays will contain each vertex key only once  even the first/last one.\n\t * @example\n\t * for (var it = graph.cycles(), kv; !(kv = it.next()).done;) {\n\t *     var cycle = kv.value;\n\t *     // iterates over all cycles of the graph\n\t * }\n\t * @example\n\t * // in ECMAScript 6, you can use a for..of loop\n\t * for (let cycle of graph.cycles()) {\n\t *     // iterates over all cycles of the graph\n\t * }\n\t */\n\t*cycles() {\n\t\t// This algorithm is based on the following article:\n\t\t// Enumeration of the elementary circuits of a directed graph\n\t\t// R. Tarjan, SIAM Journal on Computing, 2 (1973), pp. 211-216\n\t\t// http://dx.doi.org/10.1137/0202017\n\t\t// -----\n\t\t// TODO: implement the improved version as defined by Johnson:\n\t\t// Finding all the elementary circuits of a directed graph.\n\t\t// D. B. Johnson, SIAM Journal on Computing 4, no. 1, 77-84, 1975.\n\t\t// http://dx.doi.org/10.1137/0204007\n\n\t\t/* bookkeeping */\n\t\tlet pointStack = [];\n\t\tlet markedStack, mark;\n\n\t\t/* the main recursive backtracking algorithm */\n\t\tlet _this = this;\n\t\tfunction* backtrack(v, out = {}) {\n\t\t\tpointStack.push(v);\n\t\t\tmark.add(v);\n\t\t\tmarkedStack.push(v);\n\t\t\tfor (let [w] of [..._this.verticesFrom(v)]) {\n\t\t\t\tif (w < pointStack[0]) { continue }\n\t\t\t\tif (w === pointStack[0]) {\n\t\t\t\t\tyield [...pointStack];\n\t\t\t\t\tout.found = true;\n\t\t\t\t} else if (!mark.has(w)) {\n\t\t\t\t\tlet o = {};\n\t\t\t\t\tyield* backtrack(w, o);\n\t\t\t\t\tout.found = out.found || o.found;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (out.found) { // if a simple cycle continuing the partial path on the pointStack has been found\n\t\t\t\tlet u;\n\t\t\t\tdo {\n\t\t\t\t\tu = markedStack.pop();\n\t\t\t\t\tmark.delete(u);\n\t\t\t\t} while (u !== v);\n\t\t\t}\n\t\t\tpointStack.pop();\n\t\t}\n\n\t\t/* start backtracking from each vertex in the graph */\n\t\tfor (let [a] of this.vertices()) {\n\t\t\tmarkedStack = [];\n\t\t\tmark = new Set();\n\t\t\tyield* backtrack(a);\n\t\t}\n\t}\n\n\n\t/**\n\t * Find any directed cycle in this graph.\n\t * @returns {?Array} an array containing the vertex keys describing the cycle; `null`, if there is no cycle;\n\t *                   The array will contain each vertex key only once  even the first/last one.\n\t */\n\tcycle() {\n\t\tlet result = this.cycles().next();\n\t\treturn result.done ? null : result.value;\n\t}\n\n\n\t/**\n\t * Test whether this graph contains a directed cycle.\n\t * @returns {boolean} whether this graph contains any directed cycle\n\t */\n\thasCycle() { return !this.cycles().next().done }\n\n\n\t/**\n\t * Iterate over all paths between two given keys in this graph, in no particular order.\n\t * If you mutate the graph in between iterations, behavior of the iterator\n\t * becomes unspecified. (So, don't.)\n\t * @param from {string} the key for the originating vertex\n\t * @param to   {string} the key for the terminating vertex\n\t * @throws {Graph.VertexNotExistsError} if the `from` and/or `to` vertices do not yet exist in the graph\n\t * @returns {Iterator} an ES6 iterator yielding arrays containing the vertex-keys describing the path\n\t * @example\n\t * for (var it = graph.paths(from, to), kv; !(kv = it.next()).done;) {\n\t *     var path = kv.value;\n\t *     // iterates over all paths between `from` and `to` in the graph\n\t * }\n\t * @example\n\t * // in ECMAScript 6, you can use a for..of loop\n\t * for (let path of graph.paths(from, to)) {\n\t *     // iterates over all paths between `from` and `to` in the graph\n\t * }\n\t */ // TODO: allow [from, to] array to be given as argument in docs\n\tpaths(from, to) {\n\t\t[from, to] = Graph[_extractTwoArgs](from, to);\n\t\tthis[_expectVertices](from, to);\n\t\treturn this[_paths](from, to);\n\t}\n\t*[_paths](from, to) {\n\t\tlet stack = [];\n\n\t\tlet _this = this;\n\t\tfunction *pathsFromPrefix(current) {\n\t\t\tstack.push(current);\n\t\t\tfor (let [next] of _this.verticesFrom(current)) {\n\t\t\t\tif (next === to) {\n\t\t\t\t\tyield [...stack, to];\n\t\t\t\t} else if (stack.indexOf(next) === -1) {\n\t\t\t\t\tyield* pathsFromPrefix(next);\n\t\t\t\t}\n\t\t\t}\n\t\t\tstack.pop();\n\t\t}\n\n\t\tyield* pathsFromPrefix(from);\n\t}\n\n\n\t/**\n\t * Find any path between a given pair of keys.\n\t * @param from {string} the originating vertex\n\t * @param to   {string} the terminating vertex\n\t * @throws {Graph.VertexNotExistsError} if the `from` and/or `to` vertices do not yet exist in the graph\n\t * @returns {?Array} an array with the keys of the path found between the two vertices,\n\t *                   including those two vertices themselves; `null` if no such path exists\n\t */ // TODO: allow [from, to] array to be given as argument in docs\n\tpath(from, to) {\n\t\tlet result = this.paths(from, to).next();\n\t\treturn result.done ? null : result.value;\n\t}\n\n\n\t/**\n\t * Test whether there is a directed path between a given pair of keys.\n\t * @param from {string} the originating vertex\n\t * @param to   {string} the terminating vertex\n\t * @throws {Graph.VertexNotExistsError} if the `from` and/or `to` vertices do not yet exist in the graph\n\t * @returns {boolean} whether such a path exists\n\t */ // TODO: allow [from, to] array to be given as argument in docs\n\thasPath(from, to) { return !this.paths(from, to).next().done }\n\n\n\t/**\n\t * Get the number of edges going out of a given vertex.\n\t * @throws {Graph.VertexNotExistsError} if a vertex with this key does not exist\n\t * @param key {string} the key of the vertex to query\n\t * @returns {number} the number of edges going out of the `key` vertex\n\t */\n\toutDegree(key) {\n\t\tthis[_expectVertices](key);\n\t\treturn this[_edges].get(key).size;\n\t}\n\n\n\t/**\n\t * Get the number of edges coming into a given vertex.\n\t * @throws {Graph.VertexNotExistsError} if a vertex with this key does not exist\n\t * @param key {string} the key of the vertex to query\n\t * @returns {number} the number of edges coming into the `key` vertex\n\t */\n\tinDegree(key) {\n\t\tthis[_expectVertices](key);\n\t\treturn this[_reverseEdges].get(key).size;\n\t}\n\n\n\t/**\n\t * Get the number of edges connected to a given vertex.\n\t * @throws {Graph.VertexNotExistsError} if a vertex with this key does not exist\n\t * @param key {string} the key of the vertex to query\n\t * @returns {number} the number of edges connected to the `key` vertex\n\t */\n\tdegree(key) { return this.outDegree(key) + this.inDegree(key) }\n\n\n\t///////////////////////////////////////\n\t////////// Cloning and stuff //////////\n\t///////////////////////////////////////\n\n\n\t/**\n\t * Merge another graph into this graph.\n\t * @param other {Graph} the other graph to merge into this one\n\t * @param [mV] {function(*, *, string): *}\n\t *     a custom merge function for values stored in vertices;\n\t *     defaults to choosing the second value over the first; The first and\n\t *     second arguments are the vertex values of `this` graph and the\n\t *     `other` graph respectively. The third is the corresponding `key`.\n\t * @param [mE] {function(*, *, Array): *}\n\t *     a custom merge function for values stored in edges;\n\t *     defaults to whichever of the two values is not `undefined`,\n\t *     giving preference to that of the other graph; The first and\n\t *     second arguments are the edge values of `this` graph and the\n\t *     `other` graph respectively. The third is the\n\t *     corresponding `[from, to]` key.\n\t */\n\tmergeIn(other, mV=((v1,v2)=>v2), mE=mV) {\n\t\tfor (let [key, value] of other.vertices()) {\n\t\t\tthis.addVertex(key, mV(this.vertexValue(key), value, key));\n\t\t}\n\t\tfor (let [key, value] of other.edges()) {\n\t\t\tthis.addEdge(key, mE(this.edgeValue(key), value, key));\n\t\t}\n\t}\n\n\n\t/**\n\t * Create a clone of this graph.\n\t * @param [trV] {function(*, string): *}\n\t *     a custom transformation function for values stored in vertices;\n\t *     defaults to the identity function; The first argument is the\n\t *     value to clone. The second is the corresponding `key`.\n\t * @param [trE] {function(*, Array): *}\n\t *     a custom transformation function for values stored in edges;\n\t *     defaults to the function given for `trV`; The first argument\n\t *     is the value to clone. The second is the corresponding\n\t *     `[from, to]` key.\n\t * @returns {Graph} a clone of this graph\n\t */\n\tclone(trV=(v=>v), trE=trV) {\n\t\tlet result = new Graph();\n\t\tresult.mergeIn(this, (v1, v2) => trV(v2), (v1, v2) => trE(v2));\n\t\treturn result;\n\t}\n\n\n\t/**\n\t * Create a clone of this graph, but without any transitive edges.\n\t * @param [trV] {function(*, string): *}\n\t *     a custom transformation function for values stored in vertices;\n\t *     defaults to the identity function; The first argument is the\n\t *     value to clone. The second is the corresponding `key`.\n\t * @param [trE] {function(*, Array): *}\n\t *     a custom transformation function for values stored in edges;\n\t *     defaults to the function given for `trV`; The first argument\n\t *     is the value to clone. The second is the corresponding\n\t *     `[from, to]` key.\n\t * @returns {Graph} a clone of this graph with all transitive edges removed\n\t */\n\ttransitiveReduction(trV, trE) {\n\t\t// argument defaults are handled in `clone`\n\t\tlet result = this.clone(trV, trE);\n\t\tfor (let [x] of this.vertices())\n\t\t\tfor (let [y] of this.vertices())\n\t\t\t\tif (result.hasEdge(x, y))\n\t\t\t\t\tfor (let [z] of this.vertices())\n\t\t\t\t\t\tif (result.hasPath(y, z))\n\t\t\t\t\t\t\tresult.removeEdge(x, z);\n\t\treturn result;\n\t}\n\n\t/**\n\t * This method replaces stretches of non-branching directed pathway into single edges.\n\t * More specifically, it identifies all 'nexus' vertices in the graph and preserves them.\n\t * It then removes all other vertices and all edges from the graph, then inserts edges\n\t * between nexuses that summarize the connectivity that was there before.\n\t *\n\t * A nexus is any vertex that is *not* characterized by '1 edge in, 1 edge out'.\n\t * A custom `isNexus` function may be provided to manually select additional vertices\n\t * that should be preserved as nexus.\n\t * @param [isNexus] {function(string, *): boolean}\n\t *                  a predicate for identifying additional vertices that should be treated as nexus;\n\t *                  It receives a `key` and `value` associated to a vertex and should return\n\t *                  true if and only if that vertex should be a nexus.\n\t * @throws {Graph.BranchlessCycleError} if the graph contains a cycle with no branches or nexuses\n\t */\n\tcontractPaths({ isNexus } = {}) {\n\t\t/* defaults */\n\t\tif (!isNexus) { isNexus=(()=>false) }\n\n\n\t\t/* what makes a a vertex a nexus (start/end-point) */\n\t\tlet nexuses = new Set(\n\t\t\t[...this.vertices()]\n\t\t\t\t.filter(([key, val]) => this.outDegree(key) !== 1 || this.inDegree(key) !== 1 || isNexus(key, val))\n\t\t\t\t.map(([key]) => key)\n\t\t);\n\n\t\t/* error if there is a branch-less cycle */\n\t\t{\n\t\t\tlet unhandledVertices = new Set([...this.vertices()].map(([key])=>key));\n\t\t\tconst checkForBlCycle = (key) => {\n\t\t\t\tif (!unhandledVertices.has(key)) { return }\n\t\t\t\tunhandledVertices.delete(key);\n\t\t\t\tfor (let [next] of this.verticesFrom(key)) { checkForBlCycle(next) }\n\t\t\t\tfor (let [next] of this.verticesTo  (key)) { checkForBlCycle(next) }\n\t\t\t};\n\t\t\tfor (let key of nexuses) { checkForBlCycle(key) }\n\t\t\tif (unhandledVertices.size > 0) {\n\t\t\t\tlet startingKey = unhandledVertices.values().next().value,\n\t\t\t\t\tcycle       = [],\n\t\t\t\t\tcurrent     = startingKey;\n\t\t\t\tdo {\n\t\t\t\t\tcycle.push(current);\n\t\t\t\t\tcurrent = this.verticesFrom(current).next().value[0];\n\t\t\t\t} while (current !== startingKey);\n\t\t\t\tthrow new Graph.BranchlessCycleError(cycle);\n\t\t\t}\n\t\t}\n\n\t\t/* bookkeeping */\n\t\tlet contractionsToAdd = new Map();\n\n\t\t/* register the path starting with the given edge */\n\t\tconst startPath = (start, next, backwards) => {\n\t\t\t/* functions to help branch on `backwards` */\n\t\t\tconst fromTo       = (strt = start, nxt = next) => backwards ? [nxt, strt] : [strt, nxt];\n\t\t\tconst verticesNext = (v) => backwards ? this.verticesTo(v) : this.verticesFrom(v);\n\n\t\t\t/* bookkeeping */\n\t\t\tlet verticesToRemove = new Set();\n\t\t\tlet edgesToRemove    = new Set();\n\t\t\tlet path = new (this.constructor)();\n\n\t\t\t/* process the start of the path */\n\t\t\tpath.addVertex(start, this.vertexValue(start));\n\t\t\tpath.addVertex(next,  this.vertexValue(next) );\n\t\t\tpath.addNewEdge(...fromTo(), this.edgeValue(...fromTo()));\n\t\t\tedgesToRemove.add(fromTo());\n\n\t\t\t/* process as [current, next] moves across the path */\n\t\t\tlet current;\n\t\t\twhile (!nexuses.has(next)) {\n\t\t\t\t[current, next] = [next, verticesNext(next).next().value[0]];\n\t\t\t\tpath.addVertex(next, this.vertexValue(next));\n\t\t\t\tpath.addNewEdge(...fromTo(current, next), this.edgeValue(...fromTo(current, next)));\n\t\t\t\tverticesToRemove.add(current);\n\t\t\t\tedgesToRemove.add(fromTo(current, next));\n\t\t\t}\n\n\t\t\t/* register new path contraction */\n\t\t\tif (!contractionsToAdd.get(fromTo()[0]))                  { contractionsToAdd.set(fromTo()[0], new Map())                                 }\n\t\t\tif (!contractionsToAdd.get(fromTo()[0]).get(fromTo()[1])) { contractionsToAdd.get(fromTo()[0]).set(fromTo()[1], new (this.constructor)()) }\n\t\t\tcontractionsToAdd.get(fromTo()[0]).get(fromTo()[1]).mergeIn(path);\n\n\t\t\t/* remove old edges and vertices */\n\t\t\tfor (let key of edgesToRemove)    { this.removeExistingEdge(...key) }\n\t\t\tfor (let key of verticesToRemove) { this.destroyExistingVertex(key) }\n\t\t};\n\n\t\t/* process paths starting at all nexus points */\n\t\tfor (let first of nexuses) {\n\t\t\tfor (let [next] of this.verticesFrom(first)) { startPath(first, next, false) }\n\t\t\tfor (let [next] of this.verticesTo  (first)) { startPath(first, next, true)  }\n\t\t}\n\n\t\t/* add the replacement edges */\n\t\tfor (let [from, toVal] of contractionsToAdd)\n\t\t\tfor (let [to, rememberedPath] of toVal)\n\t\t\t\tthis.addNewEdge(from, to, rememberedPath);\n\t}\n\n\n\t////////////////////////////////\n\t////////// Assertions //////////\n\t////////////////////////////////\n\n\t[_expectVertices](...keys) {\n\t\tlet missingVertices = keys.filter(k => !this.hasVertex(k));\n\t\tif (missingVertices.length) { throw new Graph.VertexNotExistsError(...missingVertices) }\n\t}\n\n\t[_expectVerticesAbsent](...keys) {\n\t\tlet presentVertices = keys.filter(k => this.hasVertex(k));\n\t\tif (presentVertices.length) {\n\t\t\tthrow new Graph.VertexExistsError(...presentVertices.map(key => this.vertex(key)));\n\t\t}\n\t}\n\n\t[_expectEdges](...keys) {\n\t\tlet absentEdges = keys.filter(k => !this.hasEdge(...k));\n\t\tif (absentEdges.length) {\n\t\t\tthrow new Graph.EdgeNotExistsError(...absentEdges);\n\t\t}\n\t}\n\n\t[_expectEdgesAbsent](...keys) {\n\t\tlet presentEdges = keys.filter(k => this.hasEdge(...k));\n\t\tif (presentEdges.length) {\n\t\t\tthrow new Graph.EdgeExistsError(...presentEdges.map(key => this.edge(key)));\n\t\t}\n\t}\n\n\t[_expectNoConnectedEdges](key) {\n\t\tlet edges = [];\n\t\tfor (let [to]   of this.verticesFrom(key)) { edges.push(this.edge(key,  to )) }\n\t\tfor (let [from] of this.verticesTo  (key)) { edges.push(this.edge(from, key)) }\n\t\tif (edges.length) { throw new Graph.HasConnectedEdgesError(key, ...edges) }\n\t}\n\n}\n\n\n//  ////////////////////////////////////////////////////////////////////////////////////////////////\n//  // Errors //////////////////////////////////////////////////////////////////////////////////////\n//  ////////////////////////////////////////////////////////////////////////////////////////////////\n\n/**\n * @class\n * @classdesc This type of error is thrown when specific vertices are expected not to exist, but do.\n * @extends Error\n */\nGraph.VertexExistsError = class VertexExistsError extends Error {\n\tconstructor(...vertices) {\n\t\tsuper();\n\t\t/**\n\t\t * the set of relevant vertices as `[key, value]` shaped arrays\n\t\t * @public\n\t\t * @constant vertices\n\t\t * @memberof Graph.VertexExistsError\n\t\t * @instance\n\t\t * @type {Set.<Array>}\n\t\t */\n\t\tthis.vertices = new Set(vertices);\n\t\tthis.message = `This graph has ${\n\t\t\tthis.vertices.size === 1 ? \"a vertex\" : \"vertices\"\n\t\t} '${\n\t\t\t[...this.vertices].map(([key]) => key).join(`', '`)\n\t\t}'`;\n\t}\n};\n\n/**\n * @class\n * @classdesc This type of error is thrown when specific vertices are expected to exist, but don't.\n * @extends Error\n */\nGraph.VertexNotExistsError = class VertexNotExistsError extends Error {\n\tconstructor(...keys) {\n\t\tsuper();\n\t\t/**\n\t\t * the set of relevant vertex keys\n\t\t * @public\n\t\t * @constant vertices\n\t\t * @memberof Graph.VertexNotExistsError\n\t\t * @instance\n\t\t * @type {Set.<string>}\n\t\t */\n\t\tthis.vertices = new Set(keys);\n\t\tthis.message = `This graph does not have ${\n\t\t\tthis.vertices.size === 1 ? \"a vertex\" : \"vertices\"\n\t\t} '${\n\t\t\t[...this.vertices].join(`', '`)\n\t\t}'`;\n\t}\n};\n\n/**\n * @class\n * @classdesc This type of error is thrown when specific edges are expected not to exist, but do.\n * @extends Error\n */\nGraph.EdgeExistsError = class EdgeExistsError extends Error {\n\tconstructor(...edges) {\n\t\tsuper();\n\t\t/**\n\t\t * the set of relevant edges as `[[from, to], value]` shaped arrays\n\t\t * @public\n\t\t * @constant edges\n\t\t * @memberof Graph.EdgeExistsError\n\t\t * @instance\n\t\t * @type {Set.<Array>}\n\t\t */\n\t\tthis.edges = new Set(edges);\n\t\tthis.message = `This graph has ${\n\t\t\tthis.edges.size === 1 ? \"an edge\" : \"edges\"\n\t\t} ${\n\t\t\t[...this.edges].map(([key]) => `[${key}]`).join(`, `)\n\t\t}`;\n\t}\n};\n\n/**\n * @class\n * @classdesc This type of error is thrown when specific edges are expected to exist, but don't.\n * @extends Error\n */\nGraph.EdgeNotExistsError = class EdgeNotExistsError extends Error {\n\tconstructor(...edges) {\n\t\tsuper();\n\t\t/**\n\t\t * the set of relevant edge keys as `[from, to]` shaped arrays\n\t\t * @public\n\t\t * @constant edges\n\t\t * @memberof Graph.EdgeNotExistsError\n\t\t * @instance\n\t\t * @type {Set.<Array.<string>>}\n\t\t */\n\t\tthis.edges = new Set(edges);\n\t\tthis.message = `This graph does not have ${\n\t\t\tthis.edges.size === 1 ? \"an edge\" : \"edges\"\n\t\t} ${\n\t\t\t[...this.edges].map(([key]) => `[${key}]`).join(`, `)\n\t\t}`;\n\t}\n};\n\n/**\n * @class\n * @classdesc This type of error is thrown when a vertex is expected not to have any connected edges, but does.\n * @extends Graph.EdgeExistsError\n */\nGraph.HasConnectedEdgesError = class HasConnectedEdgesError extends Graph.EdgeExistsError {\n\tconstructor(key, ...edges) {\n\t\tsuper(...edges);\n\t\t/**\n\t\t * the key of the vertex that has connected edges\n\t\t * @public\n\t\t * @constant vertex\n\t\t * @memberof Graph.HasConnectedEdgesError\n\t\t * @instance\n\t\t * @type {string}\n\t\t */\n\t\tthis.vertex = key;\n\t\tthis.message = `The '${key}' vertex has connected ${\n\t\t\tthis.edges.size === 1 ? \"an edge\" : \"edges\"\n\t\t} ${\n\t\t\t[...this.edges].map(([key]) => `[${key}]`).join(`, `)\n\t\t}`;\n\t}\n};\n\n/**\n * @class\n * @classdesc This type of error is thrown when a graph is expected not to have a directed cycle, but does.\n * @extends Error\n */\nGraph.CycleError = class CycleError extends Error {\n\tconstructor(cycle) {\n\t\tsuper();\n\t\t/**\n\t\t * the vertices involved in the cycle, in order but with an unspecified starting point\n\t\t * @public\n\t\t * @constant cycle\n\t\t * @memberof Graph.CycleError\n\t\t * @instance\n\t\t * @type {Array.<string>}\n\t\t */\n\t\tthis.cycle = cycle;\n\t\tthis.message = `This graph contains a cycle: ${cycle}`;\n\t}\n};\n\n/**\n * @class\n * @classdesc This type of error is thrown when a graph is expected not to have a branch-less directed cycle, but does.\n * @extends Graph.CycleError\n */\nGraph.BranchlessCycleError = class BranchlessCycleError extends Graph.CycleError {\n\tconstructor(cycle) {\n\t\tsuper(cycle);\n\t\tthis.message = `This graph contains a branch-less cycle: ${cycle}`;\n\t}\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/graph.es6.js"]}